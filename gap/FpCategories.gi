# SPDX-License-Identifier: GPL-2.0-or-later
# Algebroids: Algebroids and bialgebroids as preadditive categories generated by enhanced quivers
#
# Implementations
#

####################################
#
# representations:
#
####################################

DeclareRepresentation( "IsCapCategoryObjectInFpCategoryRep",
        IsCapCategoryObjectInFpCategory and
        IsAttributeStoringRep,
        [ ] );

DeclareRepresentation( "IsCapCategoryMorphismInFpCategoryRep",
        IsCapCategoryMorphismInFpCategory and
        IsAttributeStoringRep,
        [ ] );

####################################
#
# methods for attributes:
#
####################################

##
InstallMethod( SetOfObjects,
        "for an algebroid",
        [ IsFpCategory and HasUnderlyingQuiver ],
        
  A -> List( Vertices( UnderlyingQuiver( A ) ), o -> A.( String( o ) ) ) );

##
InstallMethod( AssignSetOfObjects,
        [ IsFpCategory and HasUnderlyingQuiver, IsString ],
  function( A, label )
    local names, objects, func;
    
    names := List( Vertices( UnderlyingQuiver( A ) ), String );
    
    objects := SetOfObjects( A );
    
    func := function( name, o )
              
              if Int( name ) <> fail and label = "" then
                  Error( "The second argument should be a non-empty string" );
              fi;
              
              name := Concatenation( label, ReplacedString( name, "-", "m" ) );
              
              MakeReadWriteGlobal( name );
              
              DeclareSynonym( name, o );
              
              return 1;
              
            end;
            
    ListN( names, objects, func );
    
end );

##
InstallOtherMethod( AssignSetOfObjects,
        [ IsFpCategory and HasUnderlyingQuiver ],
  function( A )
  
    AssignSetOfObjects( A, "" );
    
end );

##
InstallMethod( SetOfGeneratingMorphisms,
        "for an algebroid",
        [ IsFpCategory and HasUnderlyingQuiver ],
        
  A -> List( Arrows( UnderlyingQuiver( A ) ), o -> A.(String( o ) ) ) );

##
InstallMethodWithCache( SetOfGeneratingMorphisms,
        "for and algebroid and two objects",
        [ IsFpCategory and HasUnderlyingQuiver, IsCapCategoryObjectInFpCategory, IsCapCategoryObjectInFpCategory ],
        
  { A, obj_1, obj_2 } -> Filtered( SetOfGeneratingMorphisms( A ), m -> IsEqualForObjects( obj_1, Source( m ) ) and IsEqualForObjects( obj_2, Range( m ) ) )
);

##
InstallMethod( SetOfGeneratingMorphisms,
        "for two objects in an algebroid",
         [ IsCapCategoryObjectInFpCategory, IsCapCategoryObjectInFpCategory ],
         
  { obj_1, obj_2 } -> SetOfGeneratingMorphisms( CapCategory( obj_1 ), obj_1, obj_2 )
);

##
InstallMethodWithCache( SetOfGeneratingMorphisms,
        "for and algebroid and two integers",
        [ IsFpCategory and HasUnderlyingQuiver, IsInt, IsInt ],
        
  { A, i, j } -> SetOfGeneratingMorphisms( A, SetOfObjects( A )[ i ], SetOfObjects( A )[ j ] )
);

##
InstallMethod( AssignSetOfGeneratingMorphisms,
        [ IsFpCategory and HasUnderlyingQuiver, IsString ],
  function( A, label )
    local names, morphisms, func;
    
    names := List( Arrows( UnderlyingQuiver( A ) ), String );
    
    morphisms := SetOfGeneratingMorphisms( A );
    
    func := function( name, m )
              
              if Int( name ) <> fail and label = "" then
                  Error( "The second argument should be a non-empty string" );
              fi;
              
              name := Concatenation( label, ReplacedString( name, "-", "m" ) );
              
              MakeReadWriteGlobal( name );
              
              DeclareSynonym( name, m );
              
              return 1;
              
            end;
            
    ListN( names, morphisms, func );
    
end );

##
InstallOtherMethod( AssignSetOfGeneratingMorphisms,
        [ IsFpCategory and HasUnderlyingQuiver ],
  function( A )
    
    AssignSetOfGeneratingMorphisms( A, "" );
    
end );

##
InstallMethod( RelationsOfFpCategory,
        "for an algebroid",
        [ IsFpCategory and HasUnderlyingQuiverAlgebra ],
        
  function( A )
    local relations;
    
    relations := RelationsOfAlgebra( UnderlyingQuiverAlgebra( A ) );
    
    relations := Filtered( relations, r -> not IsZero( r ) );
    
    return List( relations, a -> MorphismInFpCategory( A, a ) );
    
end );

####################################
#
# methods for constructors:
#
####################################

##
InstallGlobalFunction( ADD_FUNCTIONS_FOR_FP_CATEGORY,
  
  function( category )
    
    ##
    AddIsWellDefinedForObjects( category,
      function( o )
        
        o := UnderlyingVertex( o );
        
        return IsQuiverVertex( o ) and IsIdenticalObj( QuiverOfPath( o ), UnderlyingQuiver( category ) );
        
      end );
    
    ##
    AddIsWellDefinedForMorphisms( category,
      function( alpha )
        local m, v, w;
        
        m := UnderlyingQuiverAlgebraElement( alpha );
        
        if not IsIdenticalObj( AlgebraOfElement( m ), UnderlyingQuiverAlgebra( category ) ) then
            
            return false;
            
        fi;
        
        if not IsUniform( m ) then
            
            return false;
            
        fi;
        
        if IsQuotientOfPathAlgebraElement( m ) then
            
            m := Representative( m );
            
        fi;
        
        if not Coefficients( m ) = [ 1 ] then
            
            return false;
            
        fi;
        
        v := Source( LeadingPath( m ) );
        
        if not ( UnderlyingVertex( Source( alpha ) ) = v ) then
            
            return false;
            
        fi;
        
        w := Target( LeadingPath( m ) );
        
        if not ( UnderlyingVertex( Range( alpha ) ) = w ) then
            
            return false;
            
        fi;
        
        # all tests passed, so it is well-defined
        return true;
        
      end );
    
    ##
    AddIsEqualForObjects( category,
      function( object_1, object_2 )
        
        return UnderlyingVertex( object_1 ) = UnderlyingVertex( object_2 );
        
    end );
    
    ##
    AddIsEqualForMorphisms( category,
      function( morphism_1, morphism_2 )
        
        return UnderlyingQuiverAlgebraElement( morphism_1 ) = UnderlyingQuiverAlgebraElement( morphism_2 );
        
    end );
    
    ##
    AddIsCongruentForMorphisms( category,
      function( morphism_1, morphism_2 )
        
        return UnderlyingQuiverAlgebraElement( morphism_1 ) = UnderlyingQuiverAlgebraElement( morphism_2 );
        
    end );
    
    ##
    AddIdentityMorphism( category,
      function( object )
        local quiver_algebra, id;
        
        quiver_algebra := UnderlyingQuiverAlgebra( CapCategory( object ) );
        
        id := PathAsAlgebraElement( quiver_algebra, UnderlyingVertex( object ) );
        
        return MorphismInFpCategory(
                       object,
                       id,
                       object );
        
    end );
    
    ##
    AddPreCompose( category,
      function( morphism_1, morphism_2 )
        local B, quiver;
        
        B := CapCategory( morphism_1 );
        
        quiver := UnderlyingQuiver( B );
        
        if IsRightQuiver( quiver ) then
            return MorphismInFpCategory(
                           Source( morphism_1 ),
                           UnderlyingQuiverAlgebraElement( morphism_1 ) * UnderlyingQuiverAlgebraElement( morphism_2 ),
                           Range( morphism_2 ) );
        else
            return MorphismInFpCategory(
                           Source( morphism_1 ),
                           UnderlyingQuiverAlgebraElement( morphism_2 ) * UnderlyingQuiverAlgebraElement( morphism_1 ),
                           Range( morphism_2 ) );
        fi;
        
    end );
    
    ## only create the Hom-structure for finite dimensional quiver algebras
    #if IsFiniteDimensional( UnderlyingQuiverAlgebra( category ) ) then
    #    
    #    ADD_FUNCTIONS_FOR_HOM_STRUCTURE_OF_FP_CATEGORY( category );
    #    
    #    ADD_FUNCTIONS_FOR_RANDOM_METHODS_OF_FP_CATEGORY( category );
    #    
    #fi;
    
    Finalize( category );
    
    SetFilterObj( IdentityFunctor( category ), IsFpCategoryMorphism );
    
    return category;
    
end );

##
InstallMethod( Category,
        "for a QPA quiver algebra",
        [ IsQuiverAlgebra ],
        
  function( A )
    local domain, parity, quiver, C, relations, rels;
    
    domain := LeftActingDomain( A );
    
    if IsRightQuiverAlgebra( A ) then
        parity := "right";
    else
        parity := "left";
    fi;
    
    quiver := QuiverOfAlgebra( A );
    
    if Length( Vertices( quiver ) ) > 1 then
        C := "Category";
    else
        C := "Monoid";
    fi;
    
    if IsPathAlgebra( A ) then
        C := Concatenation( C, " freely" );
    fi;
    
    C := Concatenation( C, " generated by the ", parity, " quiver ", String( quiver ) );
    
    relations := CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "relations", [ ] );
    
    if not IsPathAlgebra( A ) then
        C := Concatenation( C, " with relations" );
    fi;
    
    if not relations = [ ] and Length( relations ) < 6 then
        
        rels := Concatenation(
                        " [",
                        JoinStringsWithSeparator( List( relations, a -> Concatenation( " ", String( a[1] ), " = ", String( a[2] ) ) ) ),
                        " ]" );
        
        C := Concatenation( C, rels );
        
    fi;
    
    C := CreateCapCategory( C );
    
    C!.relations := relations;
    
    DeactivateCachingOfCategory( C );
    CapCategorySwitchLogicOff( C );
    DisableSanityChecks( C );
    
    AddObjectRepresentation( C, IsCapCategoryObjectInFpCategoryRep );
    AddMorphismRepresentation( C, IsCapCategoryMorphismInFpCategoryRep );
    
    SetIsFinitelyPresentedCategory( C, true );
    SetUnderlyingQuiver( C, quiver );
    SetUnderlyingAlgebra( C, domain );
    SetParity( C, parity );
    
    SetUnderlyingQuiverAlgebra( C, A );
    SetFilterObj( C, IsFpCategory );
    if Length( Vertices( quiver ) ) = 1 then
        SetFilterObj( C, IsMonoidAsCategory );
        if Length( Arrows( quiver ) ) <= 1 then
            SetIsCommutative( C, true );
        fi;
    fi;
    
    C!.Vertices := rec( );
    C!.Arrows := rec( );
    
    return ADD_FUNCTIONS_FOR_FP_CATEGORY( C );
    
end );

##
InstallMethod( Category,
        "for a QPA path algebra and a list",
        [ IsPathAlgebra, IsList ],
        
  function( Qq, L )
    local relations;
    
    if not ( IsList( L ) and
             ForAll( L, IsList ) and
             ForAll( L, a -> Length( a ) = 2 ) and
             ForAll( L, a -> ForAll( a, IsPath ) ) ) then
        
        Error( "the relations should be given as a list of pairs of paths\n" );
        
    fi;
    
    relations := List( L, a -> PathAsAlgebraElement( Qq, a[1] ) - PathAsAlgebraElement( Qq, a[2] ) );
    
    return Category( Qq / Ideal( Qq, relations ) : relations := L );
    
end );

##
InstallMethod( Category,
        "for a QPA quiver",
        [ IsQuiver, IsList ],
        
  function( quiver, L )
    
    return Category( PathAlgebra( ALGEBRIODS.ring, quiver ), L );
    
end );

##
InstallMethod( Category,
        "for a QPA quiver",
        [ IsQuiver ],
        
  function( quiver )
    
    return Category( quiver, [ ] );
    
end );

##
InstallMethod( Multiplication,
        "for a commutative algebra as cateogry",
        [ IsMonoidAsCategory and IsCommutative ],
        
  function( A )
    local unique_object_in_A, unique_object_in_A_string,
          morphisms_in_A, A2, unique_object_in_A2, unique_object_in_A2_string,
          mult_functor_images_of_objects, mult_functor_images_of_generating_morphisms,
          a, b, axg, axg_string, fxb, fxb_string, mult_functor, g, f;

    unique_object_in_A := SetOfObjects( A )[1];
    unique_object_in_A_string := String( UnderlyingVertex( unique_object_in_A ) );
    morphisms_in_A := SetOfGeneratingMorphisms(A);

    A2 := A*A;
    
    unique_object_in_A2 := SetOfObjects( A2 )[1];
    unique_object_in_A2_string := String( UnderlyingVertex( unique_object_in_A2 ) );
    
    mult_functor_images_of_objects := rec( );
    mult_functor_images_of_objects.(unique_object_in_A2_string) := unique_object_in_A;

    mult_functor_images_of_generating_morphisms := rec(); # FIXME

    a := unique_object_in_A;
    b := unique_object_in_A;

    for g in morphisms_in_A do

        axg := ElementaryTensor( a, g, A2 );
        axg_string := String( LeadingPath( Representative( UnderlyingQuiverAlgebraElement( axg ) ) ) );

        mult_functor_images_of_generating_morphisms.(axg_string) := g;

    od;

    for f in morphisms_in_A do

        fxb := ElementaryTensor( f, b, A2 );
        fxb_string := String( LeadingPath( Representative( UnderlyingQuiverAlgebraElement( fxb ) ) ) );

        mult_functor_images_of_generating_morphisms.(fxb_string) := f;

    od;
    
    mult_functor := CapFunctor( A2, mult_functor_images_of_objects, mult_functor_images_of_generating_morphisms );
    
    return mult_functor;

end );

##
InstallMethod( Unit,
        "for algebra as category",
        [ IsMonoidAsCategory ],
        
  function( A )
    
    local unique_object_in_A, unique_object_in_A_string,
          unique_object_in_A0, unique_object_in_A0_string,
          unit_functor_images_of_objects, unit_functor_images_of_generating_morphisms, A0;
    
    unique_object_in_A := SetOfObjects( A )[1];
    unique_object_in_A_string := String( UnderlyingVertex( unique_object_in_A ) );
    
    A0 := A^0;
    
    unique_object_in_A0 := SetOfObjects( A0 )[1];
    unique_object_in_A0_string := String( UnderlyingVertex( unique_object_in_A0 ) );
    
    unit_functor_images_of_objects := rec( );
    unit_functor_images_of_objects.(unique_object_in_A0_string) := unique_object_in_A;
    
    unit_functor_images_of_generating_morphisms := rec( );
    
    return CapFunctor( A0, unit_functor_images_of_objects, unit_functor_images_of_generating_morphisms );
    
end );

##
InstallMethod( \.,
        "for an algebroid and a positive integer",
        [ IsFpCategory, IsPosInt ],
        
  function( C, string_as_int )
    local name, q, a, b;
    
    name := NameRNam( string_as_int );
    
    q := UnderlyingQuiver( C );
    
    a := q.(name);
    
    b := rec( );
    
    if IsQuiverVertex( a ) then
        if IsBound( C!.Vertices.(name) ) then
            return C!.Vertices.(name);
        fi;
        ObjectifyObjectForCAPWithAttributes(
            b, C,
            UnderlyingVertex, a
        );
        C!.Vertices.(name) := b;
    elif IsArrow( a ) or IsCompositePath( a ) then
        if IsBound( C!.Arrows.(name) ) then
            return C!.Arrows.(name);
        fi;
        b := MorphismInFpCategory(
                     C.(String( Source( a ) ) ),
                     PathAsAlgebraElement( UnderlyingQuiverAlgebra( C ), a ),
                     C.(String( Target( a ) ) ) );
        C!.Arrows.(name) := b;
    else
        Error( "the given component ", name, " is neither a vertex nor an arrow of the quiver q = ", q, "\n" );
    fi;
    
    return b;
    
end );

##
InstallMethod( ObjectInFpCategory,
         "for an algebroid and a vertex of a quiver",
        [ IsFpCategory, IsQuiverVertex ],
  function( C, v )
    local o;
    o := rec();
    ObjectifyObjectForCAPWithAttributes(
        o, C,
        UnderlyingVertex, v
    );
    C!.Vertices.(String(v)) := o;
    return o;
end );

##
InstallMethod( \/,
        [ IsQuiverVertex, IsFpCategory ],
        
  { v, C } -> ObjectInFpCategory( C, v )
);

##
InstallMethod( MorphismInFpCategory,
        "for two objects in an algebroid and an element of the quiver algebra",
        [ IsCapCategoryObjectInFpCategoryRep, IsQuiverAlgebraElement, IsCapCategoryObjectInFpCategoryRep ],
        
  function( S, path, T )
    local l, mor, C;
    
    if IsZero( path ) then
        Error( "the quiver algebra element ", path, " is zero\n" );
    fi;
        
    if not IsUniform( path ) then
        Error( "the quiver algebra element ", path, " is neither zero nor uniform\n" );
    fi;
    
    if IsPathAlgebraElement( path ) then
        l := LeadingPath( path );
        
        if not ( Source( l ) = UnderlyingVertex( S ) ) and not ( Target( l ) = UnderlyingVertex( T ) ) then
            Error( "the path algebra element ", path, " does not match the given source S and it does not match the given target T\n" );
        elif not ( Source( l ) = UnderlyingVertex( S ) ) then
            Error( "the path algebra element ", path, " does not match the given source S\n" );
        elif not ( Target( l ) = UnderlyingVertex( T ) ) then
            Error( "the path algebra element ", path, " does not match the given target T\n" );
        fi;
    fi;
    
    mor := rec( );
    
    if not IsIdenticalObj( CapCategory(S), CapCategory(T) ) then
        Error( "source and target do not belong to the same category");
    fi;
    
    C := CapCategory( S );
    
    ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes(
            mor, C,
            S,
            T,
            UnderlyingQuiverAlgebraElement, path
            );
    
    return mor;
    
end );

##
InstallMethod( MorphismInFpCategory,
        "for an algebroid and an element of a path algebra",
        [ IsFpCategory, IsPathAlgebraElement ],
        
  function( C, path )
    local l, S, T;
    
    if IsZero( path ) then
        Error( "the path algebra element ", path, " is a zero path\n" );
    elif not IsUniform( path ) then
        Error( "the path algebra element ", path, " is not uniform\n" );
    elif not Coefficients( path ) = [ 1 ] then
        Error( "the path algebra element ", path, " is not a path\n" );
    fi;
    
    l := LeadingPath( path );
    
    S := String( Source( l ) );
    T := String( Target( l ) );
    
    return MorphismInFpCategory( C.(S), path, C.(T) );
    
end );

##
InstallMethod( MorphismInFpCategory,
        "for an algebroid and an element of a quotient of a path algebra",
        [ IsFpCategory, IsQuotientOfPathAlgebraElement ],
        
  function( A, path )
    local l, S, T;
    
    if IsZero( path ) then
        Error( "source and target of the zero path is ambiguous\n" );
    elif not IsUniform( path ) then
        Error( "the quiver algebra element ", path, " is not uniform\n" );
    fi;
    
    l := LeadingPath( Representative( path ) );
    
    S := String( Source( l ) );
    T := String( Target( l ) );
    
    return MorphismInFpCategory( A.(S), path, A.(T) );
    
end );

##
InstallMethod( MorphismInFpCategory,
        "for an algebroid and a path",
        [ IsFpCategory, IsPath ],
        
  function( C, path )
    
    path := PathAsAlgebraElement( UnderlyingQuiverAlgebra( C ), path );
    
    return MorphismInFpCategory( C, path );
    
end );

##
InstallMethod( \/,
        [ IsPath, IsFpCategory ],
        
  function( path, C )
    
    return MorphismInFpCategory( C, path );
    
end );

##
InstallMethod( POW,
        "for an algebroid and an integer",
        [ IsFpCategory and HasUnderlyingQuiverAlgebra, IsInt ],
        
  function( C, n )
    local Qq, R, parity;
    
    if n < 0 then
        Error( "the only admissible values for n are non-negative integers\n" );
    elif n = 1 then
        return C;
    elif not IsBound( C!.powers ) then
        C!.powers := rec( );
    fi;
    
    Qq := UnderlyingQuiverAlgebra( C );
    
    R := LeftActingDomain( Qq );
    
    if n = 0 then
        
        if not IsBound( C!.powers.0 ) then
            
            if IsRightQuiverAlgebra( Qq ) then
                parity := "right";
            else
                parity := "left";
            fi;
            
            C!.powers.0 := TrivialCategory( parity );
            
        fi;
        
        return C!.powers.0;
        
    fi;
    
    C!.powers.1 := C;
    
    if not IsBound( C!.powers.(n) ) then
        if not IsBound( C!.powers.(n-1) ) then
            C!.powers.(n-1) := C^(n-1);
        fi;
        
        C!.powers.(n) := C!.powers.(n-1) * C;
        
        C!.powers.(n)!.PowerOf := C;
        
    fi;
    
    return C!.powers.(n);
    
end );

##
InstallMethod( TrivialCategory,
        "for a string",
        [ IsString ],
        
  function( parity )
    local trivial_quiver;
   
    if parity = "right" then
        trivial_quiver := RightQuiver( "*(1)[]" );
    elif parity = "left" then
        trivial_quiver := LeftQuiver( "*(1)[]" );
    else
        Error( "parity must be either \"left\" or \"right\"" );
    fi;
    
    return Category( trivial_quiver );
end );

##
InstallMethod( ElementaryTensor,
        "for objects in algebroids",
        [ IsCapCategoryObjectInFpCategory, IsCapCategoryObjectInFpCategory, IsFpCategory ],
  function( a, b, T )
      
    local product_string, a_string, b_string, product_vertex;
  
    product_vertex := PathInProductQuiver( QuiverOfAlgebra( UnderlyingQuiverAlgebra( T ) ), [ UnderlyingVertex( a ), UnderlyingVertex( b ) ] );
    product_string := String(product_vertex);
  
    return T.(product_string);

end );

##
InstallMethod( ElementaryTensor,
        "for object and morphism in algebroids",
        [ IsCapCategoryObjectInFpCategory, IsCapCategoryMorphismInFpCategory, IsFpCategory ],
        
  function( object, morphism, T )
    local source, range, morphism_as_quiver_algebra_element, path,
          object_underlying_vertex, object_string, mors, o;
    
    source := ElementaryTensor( object, Source( morphism ), T );
    range := ElementaryTensor( object, Range( morphism ), T );
    
    morphism_as_quiver_algebra_element := UnderlyingQuiverAlgebraElement( morphism );
    
    if IsQuotientOfPathAlgebraElement( morphism_as_quiver_algebra_element ) then
        
        morphism_as_quiver_algebra_element := Representative( morphism_as_quiver_algebra_element );
        
    fi;
    
    path := Paths( morphism_as_quiver_algebra_element );
    
    if not ( Length( path ) = 1 and Coefficients( morphism_as_quiver_algebra_element ) = [ 1 ] ) then
        Error( "the morphism ", morphism, " is not well defined\n" );
    fi;

    path := path[1];
    
    object_underlying_vertex := UnderlyingVertex( object );
    object_string := String( object_underlying_vertex );
    
    mors := List( List( ArrowList( path ),
                    b -> PathInProductQuiver( QuiverOfAlgebra( UnderlyingQuiverAlgebra( T ) ), [ object_underlying_vertex, b ] ) ),
                  b -> MorphismInFpCategory(
                          ObjectInFpCategory( T, Source( b ) ),
                          QuiverAlgebraElement( UnderlyingQuiverAlgebra( T ), [ 1 ], [ b ] ),
                          ObjectInFpCategory( T, Target( b ) ) ) );
    
    if Length( mors ) = 0 then
        
        Assert( 3, IsQuiverVertex( path ) );
        
        o := ObjectInFpCategory( CapCategory( morphism ), path );
        
        Assert( 3, o = Source( morphism ) and o = Range( morphism ) );
        
        return IdentityMorphism( ElementaryTensor( object, o, T ) );
        
    fi;
    
    return PreCompose( mors );
    
end );

##
InstallMethod( ElementaryTensor,
        "for morphism and object in algebroids",
        [ IsCapCategoryMorphismInFpCategory, IsCapCategoryObjectInFpCategory, IsFpCategory ],
        
  function( morphism, object, T )
    local source, range, morphism_as_quiver_algebra_element, path,
          object_underlying_vertex, object_string, mors, o;
    
    source := ElementaryTensor( Source( morphism ), object, T );
    range := ElementaryTensor( Range( morphism ), object, T );
    
    morphism_as_quiver_algebra_element := UnderlyingQuiverAlgebraElement( morphism );
    
    if IsQuotientOfPathAlgebraElement( morphism_as_quiver_algebra_element ) then
        
        morphism_as_quiver_algebra_element := Representative( morphism_as_quiver_algebra_element );
        
    fi;

    path := Paths( morphism_as_quiver_algebra_element );
    
    if not ( Length( path ) = 1 and Coefficients( morphism_as_quiver_algebra_element ) = [ 1 ] ) then
        Error( "the morphism ", morphism, " is not well defined\n" );
    fi;
    
    path := path[1];
    
    object_underlying_vertex := UnderlyingVertex( object );
    object_string := String( object_underlying_vertex );
    
    mors := List( List( ArrowList( path ),
                    a -> PathInProductQuiver( QuiverOfAlgebra( UnderlyingQuiverAlgebra( T ) ), [ a, object_underlying_vertex ] ) ),
                  a -> MorphismInFpCategory(
                          ObjectInFpCategory( T, Source( a ) ),
                          QuiverAlgebraElement( UnderlyingQuiverAlgebra( T ), [ 1 ], [ a ] ),
                          ObjectInFpCategory( T, Target( a ) ) ) );
    
    if Length( mors ) = 0 then
        
        Assert( 3, IsQuiverVertex( path ) );
        
        o := ObjectInFpCategory( CapCategory( morphism ), path );
        
        Assert( 3, o = Source( morphism ) and o = Range( morphism ) );
        
        return IdentityMorphism( ElementaryTensor( o, object, T ) );
        
    fi;
    
    return PreCompose( mors );
    
end );

##
InstallMethod( \*,
        "for two algebroids",
        [ IsFpCategory and HasUnderlyingQuiverAlgebra, IsFpCategory and HasUnderlyingQuiverAlgebra ],
        
  function( A, B )

    return Category( TensorProductOfAlgebras( UnderlyingQuiverAlgebra( A ), UnderlyingQuiverAlgebra( B ) ) );
    
end );

##
InstallMethod( CapFunctor,
        "for an algebroid, two lists, a CAP Category, and a boolean",
        [ IsFpCategory, IsList, IsList, IsCapCategory, IsBool ],
        
  function( A, images_of_objects, images_of_generating_morphisms, B, covariant )
    local kq, vertices, arrows, functor, func_obj, func_mor;
    
    kq := QuiverOfAlgebra( UnderlyingQuiverAlgebra( A ) );
    
    vertices := Vertices( kq );
    arrows := Arrows( kq );
    
    functor := Concatenation( "Functor from ", Name( A ), " -> ", Name( B ) );
    
    functor := CapFunctor( functor, A, B );
    
    functor!.ValuesOnAllObjects := images_of_objects;
    functor!.ValuesOnAllGeneratingMorphisms := images_of_generating_morphisms;
    
    functor!.IsContravariant := not covariant;
    
    DeactivateCachingObject( ObjectCache( functor ) );
    DeactivateCachingObject( MorphismCache( functor ) );
    
    SetFilterObj( functor, IsFpCategoryMorphism );
    
    AddObjectFunction( functor,
      function( obj )
        local i;
        
        i := Position( vertices, UnderlyingVertex( obj ) );
        
        if IsInt( i ) then
            return images_of_objects[i];
        fi;
        
        Error( "vertex UnderlyingVertex( obj ) = ", UnderlyingVertex( obj ), " not found in the list ", vertices, " of vertices\n" );
        
    end );
    
    func_obj := o -> images_of_objects[ Position( vertices, o ) ];
    func_mor := a -> images_of_generating_morphisms[ Position( arrows, a ) ];
    
    if covariant then
        
        AddMorphismFunction( functor,
          function( new_source, mor, new_range )
            local i;
            
            mor := UnderlyingQuiverAlgebraElement( mor );
            
            i := Position( arrows, mor );
            
            if IsInt( i ) then
                return images_of_generating_morphisms[i];
            fi;
            
            return ApplyToQuiverAlgebraElement( func_obj, func_mor, B, mor, true );
            
        end );
        
    else
        
        AddMorphismFunction( functor,
          function( new_source, mor, new_range )
            local i;
            
            mor := UnderlyingQuiverAlgebraElement( mor );
            
            i := Position( arrows, mor );
            
            if IsInt( i ) then
                return images_of_objects[i];
            fi;
            
            return ApplyToQuiverAlgebraElement( func_obj, func_mor, B, mor, false );
            
        end );
        
    fi;
    
    return functor;
    
end );

##
InstallMethod( CapFunctor,
        "for an algebroid, two lists, and a CAP category",
        [ IsFpCategory, IsList, IsList, IsCapCategory ],
        
  function( A, images_of_objects, images_of_generating_morphisms, B )
    
    return CapFunctor( A, images_of_objects, images_of_generating_morphisms, B, true );
    
end );

## this a convenience method
InstallMethod( CapFunctor,
        "for an algebroid, two records, and a boolean",
        [ IsFpCategory, IsRecord, IsRecord, IsBool ],
        
  function( A, rec_images_of_objects, rec_images_of_generating_morphisms, covariant )
    local kq, vertices, images_of_objects, arrows, images_of_generating_morphisms,
          mor, Qq, B;
    
    kq := QuiverOfAlgebra( UnderlyingQuiverAlgebra( A ) );
    
    vertices := Vertices( kq );
    
    images_of_objects := List( vertices, v -> rec_images_of_objects.(String( v ) ) );
    
    if images_of_objects = [ ] then
        Error( "the record rec_images_of_objects does not contain a named image of an object in the source category A\n" );
    fi;
    
    arrows := Arrows( kq );
    
    images_of_generating_morphisms := List( arrows, a -> rec_images_of_generating_morphisms.(String( a ) ) );
    
    # Construct the target category B
    if not IsEmpty( images_of_generating_morphisms ) then
        for mor in images_of_generating_morphisms do
            if IsQuiverAlgebraElement( mor ) then
                Qq := AlgebraOfElement( mor );
                B := Category( Qq );
                break;
            elif IsCapCategoryCell( mor ) then
                if not IsCapCategoryMorphism( mor ) then
                    Error( Concatenation( "the image ", mor, " is not a morphism"));
                fi;
                B := CapCategory( mor );
                break;
            fi;
        od;
    else
        B := CapCategory( images_of_objects[1] );
    fi;
    
    if not IsBound( B ) then
        Error( "unable to extract target category from the records of images\n" );
    fi;
    
    return CapFunctor( A, images_of_objects, images_of_generating_morphisms, B, covariant );
    
end );

## this a convenience method
InstallMethod( CapFunctor,
        "for an algebroid and two records",
        [ IsFpCategory, IsRecord, IsRecord ],
        
  function( A, rec_images_of_objects, rec_images_of_generating_morphisms )
    
    return CapFunctor( A, rec_images_of_objects, rec_images_of_generating_morphisms, true );
    
end );

##
InstallMethod( CategoryOverOppositeAlgebra,
        "for an algebroid",
        [ IsFpCategory and HasUnderlyingQuiver ],
        
  function( A )
    local A_op;
    
    A_op := Category( OppositeAlgebra( UnderlyingQuiverAlgebra( A ) ) );
    
    SetCategoryOverOppositeAlgebra( A_op, A );
    
    return A_op;
    
end );

####################################
#
# methods for properties:
#
####################################

##
InstallMethod( IsCommutative,
        "for an FpCategory",
        [ IsFpCategory ],
     
  function( A )
    local arrows, i, j;
    
    arrows := Arrows( UnderlyingQuiverAlgebra( A ) );
    
    for i in [ 1 .. Length( arrows ) ] do
      for j in [ (i+1) .. Length( arrows ) ] do
        if not arrows[i] * arrows[j] = arrows[j] * arrows[i] then
          return false;
        fi;
      od;
    od;
    
    return true;
    
end );

####################################
#
# View, Print, and Display methods:
#
####################################

##
InstallMethod( ViewObj,
        "for an object in an algebroid",
        [ IsCapCategoryObjectInFpCategoryRep ],

  function( o )
    
    Print( "<", StringView( UnderlyingVertex( o ) ), ">" );
    
end );

##
InstallMethod( ViewObj,
        "for a morphism in an algebroid",
        [ IsCapCategoryMorphismInFpCategoryRep ],

  function( o )
    
    if IsRightQuiverAlgebra( UnderlyingQuiverAlgebra( CapCategory( o ) ) ) then
        ViewObj( UnderlyingVertex( Source( o ) ) );
        Print( "-[" );
        ViewObj( Paths( UnderlyingQuiverAlgebraElement( o ) )[1] );
        Print( "]->" );
        ViewObj( UnderlyingVertex( Range( o ) ) );
    else
        ViewObj( UnderlyingVertex( Range( o ) ) );
        Print( "<-[" );
        ViewObj( Paths( UnderlyingQuiverAlgebraElement( o ) )[1] );
        Print( "]-" );
        ViewObj( UnderlyingVertex( Source( o ) ) );
    fi;
    
end );

##
InstallMethod( LaTeXStringOp,
          [ IsCapCategoryObjectInFpCategoryRep ],
          
  o -> LaTeXStringForQPA( UnderlyingVertex( o ) )
);

##
InstallMethod( LaTeXOutput,
          [ IsCapCategoryObjectInFpCategoryRep ],
          
  LaTeXStringOp
);

##
InstallMethod( LaTeXStringOp,
          [ IsCapCategoryMorphismInFpCategoryRep ],
          
  function( m )
    local s;
    
    s := LaTeXStringForQPA( UnderlyingQuiverAlgebraElement( m ) );
    
    if ValueOption( "OnlyDatum" ) = true then
      
      return s;
      
    else
      
      return Concatenation(
                "{", LaTeXOutput( Source( m ) ), "}-\\left(",
                "{", s, "}\\right)\\rightarrow",
                "{", LaTeXOutput( Range( m ) ), "}"
              );
              
    fi;
    
end );

##
InstallMethod( LaTeXOutput,
          [ IsCapCategoryMorphismInFpCategoryRep ],
          
  LaTeXStringOp
);
