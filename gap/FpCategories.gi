# SPDX-License-Identifier: GPL-2.0-or-later
# Algebroids: Algebroids and bialgebroids as preadditive categories generated by enhanced quivers
#
# Implementations
#

####################################
#
# methods for attributes:
#
####################################

##
InstallMethod( Size,
        "for a f.p. category",
        [ IsFpCategory ],
        
  function( A )
    
    return Dimension( UnderlyingQuiverAlgebra( A ) );
    
end );

##
InstallMethod( SetOfObjects,
        "for a f.p. category",
        [ IsFpCategory and HasUnderlyingQuiver ],
        
  A -> List( Vertices( UnderlyingQuiver( A ) ), o -> A.( String( o ) ) ) );

##
InstallOtherMethod( SetOfObjects,
        "for an initial category",
        [ IsCapCategory and IsInitialCategory ],
        
  A -> [ ] );

##
InstallMethod( AssignSetOfObjects,
        [ IsFpCategory and HasUnderlyingQuiver, IsString ],
        
  function( A, label )
    local names, objects, func;
    
    names := List( Vertices( UnderlyingQuiver( A ) ), String );
    
    objects := SetOfObjects( A );
    
    func := function( name, o )
              
              if Int( name ) <> fail and label = "" then
                  Error( "The second argument should be a non-empty string" );
              fi;
              
              name := Concatenation( label, ReplacedString( name, "-", "m" ) );
              
              MakeReadWriteGlobal( name );
              
              DeclareSynonym( name, o );
              
              return 1;
              
            end;
            
    ListN( names, objects, func );
    
end );

##
InstallOtherMethod( AssignSetOfObjects,
        [ IsFpCategory and HasUnderlyingQuiver ],
  function( A )
  
    AssignSetOfObjects( A, "" );
    
end );

##
InstallMethod( SetOfGeneratingMorphisms,
        "for a f.p. category",
        [ IsFpCategory and HasUnderlyingQuiver ],
        
  A -> List( Arrows( UnderlyingQuiver( A ) ), o -> A.(String( o ) ) ) );

##
InstallOtherMethod( SetOfGeneratingMorphisms,
        "for an initial category",
        [ IsCapCategory and IsInitialCategory ],
        
  A -> [ ] );

##
InstallMethodWithCache( SetOfGeneratingMorphisms,
        "for a f.p. category and two objects",
        [ IsFpCategory and HasUnderlyingQuiver, IsObjectInFpCategory, IsObjectInFpCategory ],
        
  { A, obj_1, obj_2 } -> Filtered( SetOfGeneratingMorphisms( A ), m -> IsEqualForObjects( obj_1, Source( m ) ) and IsEqualForObjects( obj_2, Range( m ) ) )
);

##
InstallMethod( SetOfGeneratingMorphisms,
        "for two objects in a f.p. category",
         [ IsObjectInFpCategory, IsObjectInFpCategory ],
         
  { obj_1, obj_2 } -> SetOfGeneratingMorphisms( CapCategory( obj_1 ), obj_1, obj_2 )
);

##
InstallMethodWithCache( SetOfGeneratingMorphisms,
        "for a f.p. category and two integers",
        [ IsFpCategory and HasUnderlyingQuiver, IsInt, IsInt ],
        
  { A, i, j } -> SetOfGeneratingMorphisms( A, SetOfObjects( A )[ i ], SetOfObjects( A )[ j ] )
);

##
InstallMethod( AssignSetOfGeneratingMorphisms,
        [ IsFpCategory and HasUnderlyingQuiver, IsString ],
  function( A, label )
    local names, morphisms, func;
    
    names := List( Arrows( UnderlyingQuiver( A ) ), String );
    
    morphisms := SetOfGeneratingMorphisms( A );
    
    func := function( name, m )
              
              if Int( name ) <> fail and label = "" then
                  Error( "The second argument should be a non-empty string" );
              fi;
              
              name := Concatenation( label, ReplacedString( name, "-", "m" ) );
              
              MakeReadWriteGlobal( name );
              
              DeclareSynonym( name, m );
              
              return 1;
              
            end;
            
    ListN( names, morphisms, func );
    
end );

##
InstallOtherMethod( AssignSetOfGeneratingMorphisms,
        [ IsFpCategory and HasUnderlyingQuiver ],
  function( A )
    
    AssignSetOfGeneratingMorphisms( A, "" );
    
end );

##
InstallMethod( Opposite,
        "for a f.p. category and a cell in it",
        [ IsFpCategory, IsCellInFpCategory ],

  function( C, c )
    
    return OppositeFpCategory( C ).(Label( c ));
    
end );

####################################
#
# methods for constructors:
#
####################################

##
InstallGlobalFunction( ADD_FUNCTIONS_FOR_FP_CATEGORY,
  
  function( category )
    
    ##
    AddObjectConstructor( category,
      function( category, v )
        
        return ObjectInFpCategory( category, v );
        
    end );
    
    ##
    AddObjectDatum( category,
      function( category, o )
        
        return UnderlyingVertex( o );
        
    end );
    
    ##
    AddMorphismConstructor( category,
      function( category, source, m, range )
        
        return MorphismInFpCategory( source, m, range );
        
    end );
    
    ##
    AddMorphismDatum( category,
      function( category, m )
        
        return UnderlyingQuiverAlgebraElement( m );
        
    end );
    
    ##
    AddIsWellDefinedForObjects( category,
      function( category, o )
        
        o := UnderlyingVertex( o );
        
        return IsQuiverVertex( o ) and IsIdenticalObj( QuiverOfPath( o ), UnderlyingQuiver( category ) );
        
    end );
    
    ##
    AddIsWellDefinedForMorphisms( category,
      function( category, alpha )
        local m, v, w;
        
        m := UnderlyingQuiverAlgebraElement( alpha );
        
        if not IsIdenticalObj( AlgebraOfElement( m ), UnderlyingQuiverAlgebra( category ) ) then
            
            return false;
            
        fi;
        
        if not IsUniform( m ) then
            
            return false;
            
        fi;
        
        if IsQuotientOfPathAlgebraElement( m ) then
            
            m := Representative( m );
            
        fi;
        
        if not Coefficients( m ) = [ 1 ] then
            
            return false;
            
        fi;
        
        v := Source( LeadingPath( m ) );
        
        if not ( UnderlyingVertex( Source( alpha ) ) = v ) then
            
            return false;
            
        fi;
        
        w := Target( LeadingPath( m ) );
        
        if not ( UnderlyingVertex( Range( alpha ) ) = w ) then
            
            return false;
            
        fi;
        
        # all tests passed, so it is well-defined
        return true;
        
    end );
    
    ##
    AddIsEqualForObjects( category,
      function( category, object_1, object_2 )
        
        return UnderlyingVertex( object_1 ) = UnderlyingVertex( object_2 );
        
    end );
    
    ##
    AddIsEqualForMorphisms( category,
      function( category, morphism_1, morphism_2 )
        
        return UnderlyingQuiverAlgebraElement( morphism_1 ) = UnderlyingQuiverAlgebraElement( morphism_2 );
        
    end );
    
    ##
    AddIsCongruentForMorphisms( category,
      function( category, morphism_1, morphism_2 )
        
        return UnderlyingQuiverAlgebraElement( morphism_1 ) = UnderlyingQuiverAlgebraElement( morphism_2 );
        
    end );
    
    ##
    AddIdentityMorphism( category,
      function( category, object )
        local quiver_algebra, id;
        
        quiver_algebra := UnderlyingQuiverAlgebra( category );
        
        id := PathAsAlgebraElement( quiver_algebra, UnderlyingVertex( object ) );
        
        return MorphismInFpCategory(
                       object,
                       id,
                       object );
        
    end );
    
    ##
    AddPreCompose( category,
      function( category, morphism_1, morphism_2 )
        local quiver;
        
        quiver := UnderlyingQuiver( category );
        
        if IsRightQuiver( quiver ) then
            return MorphismInFpCategory(
                           Source( morphism_1 ),
                           UnderlyingQuiverAlgebraElement( morphism_1 ) * UnderlyingQuiverAlgebraElement( morphism_2 ),
                           Range( morphism_2 ) );
        else
            return MorphismInFpCategory(
                           Source( morphism_1 ),
                           UnderlyingQuiverAlgebraElement( morphism_2 ) * UnderlyingQuiverAlgebraElement( morphism_1 ),
                           Range( morphism_2 ) );
        fi;
        
    end );
    
    ## only create the Hom-structure for finite dimensional quiver algebras
    if IsFiniteDimensional( UnderlyingQuiverAlgebra( category ) ) then
        
        ADD_FUNCTIONS_FOR_HOM_STRUCTURE_OF_FP_CATEGORY( category );
        
        #ADD_FUNCTIONS_FOR_RANDOM_METHODS_OF_FP_CATEGORY( category );
        
    fi;
    
    Finalize( category );
    
    return category;
    
end );

##
InstallGlobalFunction( ADD_FUNCTIONS_FOR_HOM_STRUCTURE_OF_FP_CATEGORY,
  function( fpcategory )
    local quiver_algebra, quiver, vertices, basis, basis_paths_by_vertex_index, maps, representative_func, path, range_category_of_HomStructure;
    
    quiver_algebra := UnderlyingQuiverAlgebra( fpcategory );
    
    ## Prepare quick access to basis elements
    quiver := QuiverOfAlgebra( quiver_algebra );
    
    vertices := Vertices( quiver );
    
    basis := BasisPaths( CanonicalBasis( quiver_algebra ) );
    
    ## prepare the homomorphism structure
    
    ## storing the basis paths
    ## basis_paths_by_vertex_index[ v_index ][ w_index ] = [ p_1:v -> w, p_2:v -> w, ... ]
    
    basis_paths_by_vertex_index := List( vertices, i -> List( vertices, i -> [ ] ) );
    
    maps := List( vertices, i -> List( vertices, i -> [ ] ) );
    
    for path in basis do
        
        Add( basis_paths_by_vertex_index[ VertexIndex( Source( path ) ) ][ VertexIndex( Target( path ) ) ], path );
        
        Add( maps[ VertexIndex( Source( path ) ) ][ VertexIndex( Target( path ) ) ], MorphismInFpCategory( fpcategory, PathAsAlgebraElement( quiver_algebra, path ) ) );
        
    od;
    
    # if `basis_paths_by_vertex_index` would be mutable, setting the attribute below would create an (immuatable) copy, which would not be identical to `basis_paths_by_vertex_index` anymore
    MakeImmutable( basis_paths_by_vertex_index );
    
    SetBasisPathsByVertexIndex( fpcategory, basis_paths_by_vertex_index );
    
    Assert( 0, IsIdenticalObj( basis_paths_by_vertex_index, BasisPathsByVertexIndex( fpcategory ) ) );
    
    ##
    if IsQuotientOfPathAlgebra( quiver_algebra ) then
        
        representative_func := Representative;
        
    else
        
        representative_func := IdFunc;
        
    fi;
    
    range_category_of_HomStructure := RangeCategoryOfHomomorphismStructure( fpcategory );
    
    ##
    AddHomomorphismStructureOnObjects( fpcategory,
      function( fpcategory, object_1, object_2 )
        local nr_source, nr_range, basis_elements;
        
        nr_source := VertexIndex( UnderlyingVertex( object_1 ) );
        
        nr_range := VertexIndex( UnderlyingVertex( object_2 ) );
        
        basis_elements := basis_paths_by_vertex_index[nr_source][nr_range];
        
        return ObjectConstructor( range_category_of_HomStructure, Length( basis_elements ) );
        
    end );
    
    ##
    AddHomomorphismStructureOnMorphismsWithGivenObjects( fpcategory,
      function( fpcategory, source, alpha, beta, range )
        local a, b, basis_a_b, ap, bp, basis_ap_bp, elem_alpha, elem_beta, entries;
        
        a := VertexIndex( UnderlyingVertex( Range( alpha ) ) );
        
        b := VertexIndex( UnderlyingVertex( Source( beta ) ) );
        
        basis_a_b := basis_paths_by_vertex_index[a][b];
        
        ap := VertexIndex( UnderlyingVertex( Source( alpha ) ) );
        
        bp := VertexIndex( UnderlyingVertex( Range( beta ) ) );
        
        basis_ap_bp := basis_paths_by_vertex_index[ap][bp];
        
        elem_alpha := UnderlyingQuiverAlgebraElement( alpha );
        
        elem_beta := UnderlyingQuiverAlgebraElement( beta );
        
        entries := List( basis_a_b, phi -> -1 + Position( basis_ap_bp, Paths( elem_alpha * phi * elem_beta )[1] ) );
        
        return MorphismConstructor( range_category_of_HomStructure, source, entries, range );
        
    end );
    
    ##
    AddDistinguishedObjectOfHomomorphismStructure( fpcategory,
      function( fpcategory )
        
        return ObjectConstructor( range_category_of_HomStructure, 1 );
        
    end );
    
    ##
    AddInterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( fpcategory,
      function( fpcategory, alpha )
        local source, range, element, a, b, basis_elements;
        
        source := DistinguishedObjectOfHomomorphismStructure( fpcategory );
        range := HomomorphismStructureOnObjects( fpcategory, Source( alpha ), Range( alpha ) );
        
        element := UnderlyingQuiverAlgebraElement( alpha );
        
        a := VertexIndex( UnderlyingVertex( Source( alpha ) ) );
        
        b := VertexIndex( UnderlyingVertex( Range( alpha ) ) );
        
        basis_elements := basis_paths_by_vertex_index[a][b];
        
        return MorphismConstructor(
                range_category_of_HomStructure,
                source,
                [ -1 + Position( basis_elements, Paths( element )[1] ) ],
                range
              );
        
    end );
    
    ##
    AddInterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( fpcategory,
      function( fpcategory, a, b, morphism )
        local basis, element;
        
        basis := basis_paths_by_vertex_index[VertexIndex( UnderlyingVertex( a ) )][VertexIndex( UnderlyingVertex( b ) )];
        
        element := QuiverAlgebraElement( quiver_algebra, [ 1 ], basis{1 + [ AsList( morphism )[1] ]} );
        
        return MorphismInFpCategory( a, element, b );
        
    end );
    
    SetIsEquippedWithHomomorphismStructure( fpcategory, true );
    
end );

##
InstallMethodWithCache( Category,
        "for a QPA quiver algebra and a CAP category",
        [ IsQuiverAlgebra, IsCapCategory ],
        
  function( A, range_category_of_HomStructure )
    local domain, parity, quiver, C, relations, rels;
    
    domain := LeftActingDomain( A );
    
    if IsRightQuiverAlgebra( A ) then
        parity := "Right";
    else
        parity := "Left";
    fi;
    
    quiver := QuiverOfAlgebra( A );
    
    C := "FreeCategory( ";
    
    C := Concatenation( C, parity, "Quiver( \"", String( quiver ), "\" ) )" );
    
    relations := CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "relations", [ ] );
    
    if not relations = [ ] then
        
        if Length( relations ) < 6 then
            
            rels := Concatenation(
                            " [",
                            JoinStringsWithSeparator( List( relations, a -> Concatenation( " ", String( a[1] ), " = ", String( a[2] ) ) ) ),
                            " ]" );
            
            C := Concatenation( C, " /", rels );
            
        else
            
            C := Concatenation( C, " / relations" );
            
        fi;
        
    elif not IsPathAlgebra( A ) then
        
        C := Concatenation( C, " / relations" );
        
    fi;
    
    C := CreateCapCategory( C );
    
    C!.category_as_first_argument := true;
    
    C!.relations := relations;
    
    C!.compiler_hints := rec(
        category_attribute_names := [
            "SetOfObjects",
            "SetOfGeneratingMorphisms",
        ],
        category_filter := IsFpCategory,
        object_filter := IsObjectInFpCategory,
        morphism_filter := IsMorphismInFpCategory,
    );
    
    DeactivateCachingOfCategory( C );
    CapCategorySwitchLogicOff( C );
    DisableSanityChecks( C );
    
    AddObjectRepresentation( C, IsObjectInFpCategory );
    AddMorphismRepresentation( C, IsMorphismInFpCategory );
    
    SetIsFinitelyPresentedCategory( C, true );
    SetUnderlyingQuiver( C, quiver );
    SetUnderlyingAlgebra( C, domain );
    SetParity( C, parity );
    
    SetUnderlyingQuiverAlgebra( C, A );
    SetFilterObj( C, IsFpCategory );
    if Length( Vertices( quiver ) ) = 1 then
        SetFilterObj( C, IsMonoidAsCategory );
        if Length( Arrows( quiver ) ) <= 1 then
            SetIsCommutative( C, true );
        fi;
    fi;
    
    C!.Vertices := rec( );
    C!.Arrows := rec( );
    
    if IsFiniteDimensional( A ) then
        
        SetRangeCategoryOfHomomorphismStructure( C, range_category_of_HomStructure );
        
    fi;
    
    return ADD_FUNCTIONS_FOR_FP_CATEGORY( C );
    
end );

##
InstallMethod( Category,
        "for a QPA quiver algebra",
        [ IsQuiverAlgebra ],
        
  function( A )
    
    return Category( A, CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "range_of_HomStructure", SkeletalFinSets ) );
    
end );

##
InstallMethod( Category,
        "for a QPA path algebra and a list",
        [ IsPathAlgebra, IsList ],
        
  function( Qq, L )
    local relations, A, C;
    
    if not ( IsList( L ) and
             ForAll( L, IsList ) and
             ForAll( L, a -> Length( a ) = 2 ) and
             ForAll( L, a -> ForAll( a, IsPath ) ) ) then
        
        Error( "the relations should be given as a list of pairs of paths\n" );
        
    fi;
    
    relations := List( L, a -> PathAsAlgebraElement( Qq, a[1] ) - PathAsAlgebraElement( Qq, a[2] ) );
    
    A := Qq / Ideal( Qq, relations );
    
    A := Qq / GroebnerBasis( IdealOfQuotient( A ) );
    
    C := Category( A : relations := L );
    
    SetRelationsOfFpCategory( C, L );
    
    return C;
    
end );

##
InstallMethod( Category,
        "for a QPA quiver",
        [ IsQuiver, IsList ],
        
  function( quiver, L )
    
    return Category( PathAlgebra( ALGEBROIDS.ring, quiver ), L );
    
end );

##
InstallMethod( \/,
        "for a f.p. category and a list",
        [ IsFpCategory and HasUnderlyingQuiver, IsList ],
        
  function( C, L )
    local relations, f;
    
    if HasRelationsOfFpCategory( C ) then
        relations := ShallowCopy( RelationsOfFpCategory( C ) );
    else
        relations := [ ];
    fi;
    
    f :=
      function( p )
        if IsObjectInFpCategory( p ) then
            return UnderlyingVertex( p );
        fi;
        return Paths( UnderlyingQuiverAlgebraElement( p ) )[1];
    end;
    
    Append( relations, List( L, a -> List( a, f ) ) );
    
    return Category( UnderlyingQuiver( C ), relations );
    
end );

##
InstallMethod( FreeCategory,
        "for a QPA quiver",
        [ IsQuiver ],
        
  function( quiver )
    
    return Category( quiver, [ ] );
    
end );

##
InstallMethod( Multiplication,
        "for a commutative algebra as cateogry",
        [ IsMonoidAsCategory and IsCommutative ],
        
  function( A )
    local unique_object_in_A, unique_object_in_A_string,
          morphisms_in_A, A2, unique_object_in_A2, unique_object_in_A2_string,
          mult_functor_images_of_objects, mult_functor_images_of_generating_morphisms,
          a, b, axg, axg_string, fxb, fxb_string, mult_functor, g, f;

    unique_object_in_A := SetOfObjects( A )[1];
    unique_object_in_A_string := String( UnderlyingVertex( unique_object_in_A ) );
    morphisms_in_A := SetOfGeneratingMorphisms(A);

    A2 := A*A;
    
    unique_object_in_A2 := SetOfObjects( A2 )[1];
    unique_object_in_A2_string := String( UnderlyingVertex( unique_object_in_A2 ) );
    
    mult_functor_images_of_objects := rec( );
    mult_functor_images_of_objects.(unique_object_in_A2_string) := unique_object_in_A;

    mult_functor_images_of_generating_morphisms := rec(); # FIXME

    a := unique_object_in_A;
    b := unique_object_in_A;

    for g in morphisms_in_A do

        axg := ElementaryTensor( a, g, A2 );
        axg_string := String( LeadingPath( Representative( UnderlyingQuiverAlgebraElement( axg ) ) ) );

        mult_functor_images_of_generating_morphisms.(axg_string) := g;

    od;

    for f in morphisms_in_A do

        fxb := ElementaryTensor( f, b, A2 );
        fxb_string := String( LeadingPath( Representative( UnderlyingQuiverAlgebraElement( fxb ) ) ) );

        mult_functor_images_of_generating_morphisms.(fxb_string) := f;

    od;
    
    mult_functor := CapFunctor( A2, mult_functor_images_of_objects, mult_functor_images_of_generating_morphisms );
    
    return mult_functor;

end );

##
InstallMethod( Unit,
        "for algebra as category",
        [ IsMonoidAsCategory ],
        
  function( A )
    
    local unique_object_in_A, unique_object_in_A_string,
          unique_object_in_A0, unique_object_in_A0_string,
          unit_functor_images_of_objects, unit_functor_images_of_generating_morphisms, A0;
    
    unique_object_in_A := SetOfObjects( A )[1];
    unique_object_in_A_string := String( UnderlyingVertex( unique_object_in_A ) );
    
    A0 := A^0;
    
    unique_object_in_A0 := SetOfObjects( A0 )[1];
    unique_object_in_A0_string := String( UnderlyingVertex( unique_object_in_A0 ) );
    
    unit_functor_images_of_objects := rec( );
    unit_functor_images_of_objects.(unique_object_in_A0_string) := unique_object_in_A;
    
    unit_functor_images_of_generating_morphisms := rec( );
    
    return CapFunctor( A0, unit_functor_images_of_objects, unit_functor_images_of_generating_morphisms );
    
end );

##
InstallMethod( ObjectInFpCategory,
         "for a f.p. category and a vertex of a quiver",
        [ IsFpCategory, IsQuiverVertex ],
        
  function( C, v )
    local o, name;
    
    o := rec( );
    
    name := String( v );
    
    ObjectifyObjectForCAPWithAttributes(
            o, C,
            UnderlyingVertex, v,
            Label, name );
    
    C!.Vertices.(name) := o;
    
    return o;
    
end );

##
InstallMethod( \/,
        [ IsQuiverVertex, IsFpCategory ],
        
  { v, C } -> ObjectInFpCategory( C, v )
);

##
InstallMethod( MorphismInFpCategory,
        "for two objects in a f.p. category and an element of the quiver algebra",
        [ IsObjectInFpCategory, IsQuiverAlgebraElement, IsObjectInFpCategory ],
        
  function( S, path, T )
    local l, mor, C;
    
    if IsZero( path ) then
        Error( "the quiver algebra element ", path, " is zero\n" );
    fi;
        
    if not IsUniform( path ) then
        Error( "the quiver algebra element ", path, " is neither zero nor uniform\n" );
    fi;
    
    if IsPathAlgebraElement( path ) then
        l := LeadingPath( path );
        
        if not ( Source( l ) = UnderlyingVertex( S ) ) and not ( Target( l ) = UnderlyingVertex( T ) ) then
            Error( "the path algebra element ", path, " does not match the given source S and it does not match the given target T\n" );
        elif not ( Source( l ) = UnderlyingVertex( S ) ) then
            Error( "the path algebra element ", path, " does not match the given source S\n" );
        elif not ( Target( l ) = UnderlyingVertex( T ) ) then
            Error( "the path algebra element ", path, " does not match the given target T\n" );
        fi;
    fi;
    
    mor := rec( );
    
    if not IsIdenticalObj( CapCategory(S), CapCategory(T) ) then
        Error( "source and target do not belong to the same category");
    fi;
    
    C := CapCategory( S );
    
    ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes(
            mor, C,
            S,
            T,
            UnderlyingQuiverAlgebraElement, path
            );
    
    return mor;
    
end );

##
InstallMethod( MorphismInFpCategory,
        "for a f.p. category and an element of a path algebra",
        [ IsFpCategory, IsPathAlgebraElement ],
        
  function( C, path )
    local l, S, T;
    
    if IsZero( path ) then
        Error( "the path algebra element ", path, " is a zero path\n" );
    elif not IsUniform( path ) then
        Error( "the path algebra element ", path, " is not uniform\n" );
    elif not Coefficients( path ) = [ 1 ] then
        Error( "the path algebra element ", path, " is not a path\n" );
    fi;
    
    l := LeadingPath( path );
    
    S := String( Source( l ) );
    T := String( Target( l ) );
    
    return MorphismInFpCategory( C.(S), path, C.(T) );
    
end );

##
InstallMethod( \.,
        "for a f.p. category and a positive integer",
        [ IsFpCategory, IsPosInt ],
        
  function( C, string_as_int )
    local name, q, a, b;
    
    name := NameRNam( string_as_int );
    
    q := UnderlyingQuiver( C );
    
    a := q.(name);
    
    if IsQuiverVertex( a ) then
        if IsBound( C!.Vertices.(name) ) then
            return C!.Vertices.(name);
        fi;
        b := ObjectInFpCategory( C, a );
    elif IsArrow( a ) or IsCompositePath( a ) then
        if IsBound( C!.Arrows.(name) ) then
            return C!.Arrows.(name);
        fi;
        b := MorphismInFpCategory(
                     C.(String( Source( a ) ) ),
                     PathAsAlgebraElement( UnderlyingQuiverAlgebra( C ), a ),
                     C.(String( Target( a ) ) ) );
        SetLabel( b, name );
        C!.Arrows.(name) := b;
    else
        Error( "the given component ", name, " is neither a vertex nor an arrow of the quiver q = ", q, "\n" );
    fi;
    
    return b;
    
end );

##
InstallMethod( MorphismInFpCategory,
        "for a f.p. category and an element of a quotient of a path algebra",
        [ IsFpCategory, IsQuotientOfPathAlgebraElement ],
        
  function( A, path )
    local l, S, T;
    
    if IsZero( path ) then
        Error( "source and target of the zero path is ambiguous\n" );
    elif not IsUniform( path ) then
        Error( "the quiver algebra element ", path, " is not uniform\n" );
    fi;
    
    l := LeadingPath( Representative( path ) );
    
    S := String( Source( l ) );
    T := String( Target( l ) );
    
    return MorphismInFpCategory( A.(S), path, A.(T) );
    
end );

##
InstallMethod( MorphismInFpCategory,
        "for a f.p. category and a path",
        [ IsFpCategory, IsPath ],
        
  function( C, path )
    
    path := PathAsAlgebraElement( UnderlyingQuiverAlgebra( C ), path );
    
    return MorphismInFpCategory( C, path );
    
end );

##
InstallMethod( \/,
        [ IsPath, IsFpCategory ],
        
  function( path, C )
    
    return MorphismInFpCategory( C, path );
    
end );

##
InstallMethod( POW,
        "for a f.p. category and an integer",
        [ IsFpCategory and HasUnderlyingQuiverAlgebra, IsInt ],
        
  function( C, n )
    local Qq, R, parity;
    
    if n < 0 then
        Error( "the only admissible values for n are non-negative integers\n" );
    elif n = 1 then
        return C;
    elif not IsBound( C!.powers ) then
        C!.powers := rec( );
    fi;
    
    Qq := UnderlyingQuiverAlgebra( C );
    
    R := LeftActingDomain( Qq );
    
    if n = 0 then
        
        if not IsBound( C!.powers.0 ) then
            
            if IsRightQuiverAlgebra( Qq ) then
                parity := "Right";
            else
                parity := "Reft";
            fi;
            
            C!.powers.0 := TrivialCategory( parity );
            
        fi;
        
        return C!.powers.0;
        
    fi;
    
    C!.powers.1 := C;
    
    if not IsBound( C!.powers.(n) ) then
        if not IsBound( C!.powers.(n-1) ) then
            C!.powers.(n-1) := C^(n-1);
        fi;
        
        C!.powers.(n) := C!.powers.(n-1) * C;
        
        C!.powers.(n)!.PowerOf := C;
        
    fi;
    
    return C!.powers.(n);
    
end );

##
InstallMethod( TrivialCategory,
        "for a string",
        [ IsString ],
        
  function( parity )
    local trivial_quiver;
   
    if parity = "Right" then
        trivial_quiver := RightQuiver( "*(1)[]" );
    elif parity = "Left" then
        trivial_quiver := LeftQuiver( "*(1)[]" );
    else
        Error( "parity must be either \"Left\" or \"Right\"" );
    fi;
    
    return FreeCategory( trivial_quiver );
end );

##
InstallMethod( ElementaryTensor,
        "for objects in categorys",
        [ IsObjectInFpCategory, IsObjectInFpCategory, IsFpCategory ],
        
  function( a, b, T )
      
    local product_string, a_string, b_string, product_vertex;
  
    product_vertex := PathInProductQuiver( QuiverOfAlgebra( UnderlyingQuiverAlgebra( T ) ), [ UnderlyingVertex( a ), UnderlyingVertex( b ) ] );
    product_string := String(product_vertex);
  
    return T.(product_string);

end );

##
InstallMethod( ElementaryTensor,
        "for object and morphism in categorys",
        [ IsObjectInFpCategory, IsMorphismInFpCategory, IsFpCategory ],
        
  function( object, morphism, T )
    local source, range, morphism_as_quiver_algebra_element, path,
          object_underlying_vertex, object_string, mors, o;
    
    source := ElementaryTensor( object, Source( morphism ), T );
    range := ElementaryTensor( object, Range( morphism ), T );
    
    morphism_as_quiver_algebra_element := UnderlyingQuiverAlgebraElement( morphism );
    
    if IsQuotientOfPathAlgebraElement( morphism_as_quiver_algebra_element ) then
        
        morphism_as_quiver_algebra_element := Representative( morphism_as_quiver_algebra_element );
        
    fi;
    
    path := Paths( morphism_as_quiver_algebra_element );
    
    if not ( Length( path ) = 1 and Coefficients( morphism_as_quiver_algebra_element ) = [ 1 ] ) then
        Error( "the morphism ", morphism, " is not well defined\n" );
    fi;

    path := path[1];
    
    object_underlying_vertex := UnderlyingVertex( object );
    object_string := String( object_underlying_vertex );
    
    mors := List( List( ArrowList( path ),
                    b -> PathInProductQuiver( QuiverOfAlgebra( UnderlyingQuiverAlgebra( T ) ), [ object_underlying_vertex, b ] ) ),
                  b -> MorphismInFpCategory(
                          ObjectInFpCategory( T, Source( b ) ),
                          QuiverAlgebraElement( UnderlyingQuiverAlgebra( T ), [ 1 ], [ b ] ),
                          ObjectInFpCategory( T, Target( b ) ) ) );
    
    if Length( mors ) = 0 then
        
        Assert( 3, IsQuiverVertex( path ) );
        
        o := ObjectInFpCategory( CapCategory( morphism ), path );
        
        Assert( 3, o = Source( morphism ) and o = Range( morphism ) );
        
        return IdentityMorphism( ElementaryTensor( object, o, T ) );
        
    fi;
    
    return PreCompose( mors );
    
end );

##
InstallMethod( ElementaryTensor,
        "for morphism and object in categorys",
        [ IsMorphismInFpCategory, IsObjectInFpCategory, IsFpCategory ],
        
  function( morphism, object, T )
    local source, range, morphism_as_quiver_algebra_element, path,
          object_underlying_vertex, object_string, mors, o;
    
    source := ElementaryTensor( Source( morphism ), object, T );
    range := ElementaryTensor( Range( morphism ), object, T );
    
    morphism_as_quiver_algebra_element := UnderlyingQuiverAlgebraElement( morphism );
    
    if IsQuotientOfPathAlgebraElement( morphism_as_quiver_algebra_element ) then
        
        morphism_as_quiver_algebra_element := Representative( morphism_as_quiver_algebra_element );
        
    fi;

    path := Paths( morphism_as_quiver_algebra_element );
    
    if not ( Length( path ) = 1 and Coefficients( morphism_as_quiver_algebra_element ) = [ 1 ] ) then
        Error( "the morphism ", morphism, " is not well defined\n" );
    fi;
    
    path := path[1];
    
    object_underlying_vertex := UnderlyingVertex( object );
    object_string := String( object_underlying_vertex );
    
    mors := List( List( ArrowList( path ),
                    a -> PathInProductQuiver( QuiverOfAlgebra( UnderlyingQuiverAlgebra( T ) ), [ a, object_underlying_vertex ] ) ),
                  a -> MorphismInFpCategory(
                          ObjectInFpCategory( T, Source( a ) ),
                          QuiverAlgebraElement( UnderlyingQuiverAlgebra( T ), [ 1 ], [ a ] ),
                          ObjectInFpCategory( T, Target( a ) ) ) );
    
    if Length( mors ) = 0 then
        
        Assert( 3, IsQuiverVertex( path ) );
        
        o := ObjectInFpCategory( CapCategory( morphism ), path );
        
        Assert( 3, o = Source( morphism ) and o = Range( morphism ) );
        
        return IdentityMorphism( ElementaryTensor( o, object, T ) );
        
    fi;
    
    return PreCompose( mors );
    
end );

##
InstallMethod( \*,
        "for two categorys",
        [ IsFpCategory and HasUnderlyingQuiverAlgebra, IsFpCategory and HasUnderlyingQuiverAlgebra ],
        
  function( A, B )

    return Category( TensorProductOfAlgebras( UnderlyingQuiverAlgebra( A ), UnderlyingQuiverAlgebra( B ) ) );
    
end );

##
InstallMethod( CapFunctor,
        "for a f.p. category, two lists, a CAP Category, and a boolean",
        [ IsFpCategory, IsList, IsList, IsCapCategory, IsBool ],
        
  function( A, images_of_objects, images_of_generating_morphisms, B, covariant )
    local kq, vertices, arrows, functor, func_obj, func_mor;
    
    kq := QuiverOfAlgebra( UnderlyingQuiverAlgebra( A ) );
    
    vertices := Vertices( kq );
    arrows := Arrows( kq );
    
    functor := Concatenation( "Functor from ", Name( A ), " -> ", Name( B ) );
    
    functor := CapFunctor( functor, A, B );
    
    functor!.ValuesOnAllObjects := images_of_objects;
    functor!.ValuesOnAllGeneratingMorphisms := images_of_generating_morphisms;
    
    functor!.IsContravariant := not covariant;
    
    DeactivateCachingObject( ObjectCache( functor ) );
    DeactivateCachingObject( MorphismCache( functor ) );
    
    SetFilterObj( functor, IsFpCategoryMorphism );
    
    AddObjectFunction( functor,
      function( obj )
        local i;
        
        i := Position( vertices, UnderlyingVertex( obj ) );
        
        if IsInt( i ) then
            return images_of_objects[i];
        fi;
        
        Error( "vertex UnderlyingVertex( obj ) = ", UnderlyingVertex( obj ), " not found in the list ", vertices, " of vertices\n" );
        
    end );
    
    func_obj := o -> images_of_objects[ Position( vertices, o ) ];
    func_mor := a -> images_of_generating_morphisms[ Position( arrows, a ) ];
    
    if covariant then
        
        AddMorphismFunction( functor,
          function( new_source, mor, new_range )
            local i;
            
            mor := UnderlyingQuiverAlgebraElement( mor );
            
            i := Position( arrows, mor );
            
            if IsInt( i ) then
                return images_of_generating_morphisms[i];
            fi;
            
            return ApplyToQuiverAlgebraElement( func_obj, func_mor, B, mor, true );
            
        end );
        
    else
        
        AddMorphismFunction( functor,
          function( new_source, mor, new_range )
            local i;
            
            mor := UnderlyingQuiverAlgebraElement( mor );
            
            i := Position( arrows, mor );
            
            if IsInt( i ) then
                return images_of_objects[i];
            fi;
            
            return ApplyToQuiverAlgebraElement( func_obj, func_mor, B, mor, false );
            
        end );
        
    fi;
    
    return functor;
    
end );

##
InstallMethod( CapFunctor,
        "for a f.p. category, two lists, and a CAP category",
        [ IsFpCategory, IsList, IsList, IsCapCategory ],
        
  function( A, images_of_objects, images_of_generating_morphisms, B )
    
    return CapFunctor( A, images_of_objects, images_of_generating_morphisms, B, true );
    
end );

## this a convenience method
InstallMethod( CapFunctor,
        "for a f.p. category, two records, and a boolean",
        [ IsFpCategory, IsRecord, IsRecord, IsBool ],
        
  function( A, rec_images_of_objects, rec_images_of_generating_morphisms, covariant )
    local kq, vertices, images_of_objects, arrows, images_of_generating_morphisms,
          mor, Qq, B;
    
    kq := QuiverOfAlgebra( UnderlyingQuiverAlgebra( A ) );
    
    vertices := Vertices( kq );
    
    images_of_objects := List( vertices, v -> rec_images_of_objects.(String( v ) ) );
    
    if images_of_objects = [ ] then
        Error( "the record rec_images_of_objects does not contain a named image of an object in the source category A\n" );
    fi;
    
    arrows := Arrows( kq );
    
    images_of_generating_morphisms := List( arrows, a -> rec_images_of_generating_morphisms.(String( a ) ) );
    
    # Construct the target category B
    if not IsEmpty( images_of_generating_morphisms ) then
        for mor in images_of_generating_morphisms do
            if IsQuiverAlgebraElement( mor ) then
                Qq := AlgebraOfElement( mor );
                B := Category( Qq );
                break;
            elif IsCapCategoryCell( mor ) then
                if not IsCapCategoryMorphism( mor ) then
                    Error( Concatenation( "the image ", mor, " is not a morphism"));
                fi;
                B := CapCategory( mor );
                break;
            fi;
        od;
    else
        B := CapCategory( images_of_objects[1] );
    fi;
    
    if not IsBound( B ) then
        Error( "unable to extract target category from the records of images\n" );
    fi;
    
    return CapFunctor( A, images_of_objects, images_of_generating_morphisms, B, covariant );
    
end );

## this a convenience method
InstallMethod( CapFunctor,
        "for a f.p. category and two records",
        [ IsFpCategory, IsRecord, IsRecord ],
        
  function( A, rec_images_of_objects, rec_images_of_generating_morphisms )
    
    return CapFunctor( A, rec_images_of_objects, rec_images_of_generating_morphisms, true );
    
end );

##
InstallMethod( CapFunctor,
        "for a f.p. category and a CAP category object",
        [ IsFpCategory, IsCapCategoryObject ],
        
  function( A, object )
    
    return CapFunctor(
                   A,
                   ListWithIdenticalEntries( Length( SetOfObjects( A ) ), object ),
                   ListWithIdenticalEntries( Length( SetOfGeneratingMorphisms( A ) ), IdentityMorphism( object ) ),
                   CapCategory( object ) );
    
end );

##
InstallMethod( OppositeFpCategory,
        "for a f.p. category",
        [ IsFpCategory and HasRelationsOfFpCategory ],
        
  function( C )
    local relations, range_category, C_op;
    
    relations := RelationsOfFpCategory( C );
    
    relations := List( relations, a -> List( a, OppositePath ) );
    
    if HasRangeCategoryOfHomomorphismStructure( C ) then
        range_category := RangeCategoryOfHomomorphismStructure( C );
    else
        range_category := fail;
    fi;
    
    C_op := Category(
                    OppositeQuiver( UnderlyingQuiver( C ) ),
                    relations : range_of_HomStructure := range_category );
    
    SetOppositeFpCategory( C_op, C );
    
    return C_op;
    
end );

##
InstallMethod( NerveTruncatedInDegree2AsFunctor,
        [ IsFpCategory ],
        
  function ( B )
    local A, Delta2, H, Delta2op, B0, N0, D00, N0N0, p21, p22, B1, N1, d, id, pi2, s, t,
          D000, N0N0N0, p31, p32, p33, B2, N2, T, ds, is, dt, it,
          p312, p323, p313, pi3, pi312, pi323, pi313, ps, pt, mus, mu,
          Nerve_ValuesOnAllObjects, Nerve_ValuesOnAllGeneratingMorphisms, name;
    
    A := UnderlyingQuiverAlgebra( B );
    
    if not IsFiniteDimensional( A ) then
        
        Error( "The underlying quiver algebra A is not finite dimensional\n" );
        
    fi;
    
    Delta2 := SimplicialCategoryTruncatedInDegree( 2 );
    
    H := RangeCategoryOfHomomorphismStructure( B );
    
    ## Delta_op(C0,C1,C2)[id:C0->C1,s:C1->C0,t:C1->C0,is:C1->C2,it:C1->C2,ps:C2->C1,pt:C2->C1,mu:C2->C1]
    Delta2op := OppositeFpCategory( Delta2 );
    
    B0 := SetOfObjects( B );
    N0 := FinSet( H, Length( B0 ) );
    
    ## N0 × N0
    D00 := [ N0, N0 ];
    N0N0 := DirectProduct( D00 );
    
    ## N0 × N0 -> N0
    p21 := ProjectionInFactorOfDirectProduct( D00, 1 );
    p22 := ProjectionInFactorOfDirectProduct( D00, 2 );
    
    B1 := List( N0N0,
                i -> HomomorphismStructureOnObjects( B0[1 + p21( i )], B0[1 + p22( i )] ) );
    
    N1 := Coproduct( B1 );
    
    ## N0 -> N0 × N0
    d := EmbeddingOfEqualizer( [ p21, p22 ] );
    Assert( 0, d = UniversalMorphismIntoDirectProduct( D00, N0, [ IdentityMorphism( N0 ), IdentityMorphism( N0 ) ] ) );
    
    ## N0 -> N1
    id := MapOfFinSets(
                  N0,
                  List( N0,
                        i -> PreCompose(
                                InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( IdentityMorphism( B0[1 + i] ) ),
                                InjectionOfCofactorOfCoproduct( B1, 1 + d( i ) ) )( 0 ) ),
                  N1 );
    
    ## N1 -> N0 × N0
    ## this morphism is mixing two levels and is not a CAP operation:
    ## the coproduct N1 in SkeletalFinSets is taken over the index set N0N0 (here also realized as an object in SkeletalFinSets),
    ## so this morphism is a fibration of a coproduct over its "index set" which are both assumed to objects in the same category:
    pi2 := MapOfFinSets( N1, Concatenation( List( N0N0, i -> ListWithIdenticalEntries( Length( B1[1 + i] ), i ) ) ), N0N0 );
    
    ## N1 -> N0 × N0 -> N0
    s := PreCompose( pi2, p21 );
    
    ## N1 -> N0 × N0 -> N0
    t := PreCompose( pi2, p22 );
    
    ## N0 × N0 × N0
    D000 := [ N0, N0, N0 ];
    N0N0N0 := DirectProduct( D000 );
    
    ## N0 × N0 × N0 -> N0
    p31 := ProjectionInFactorOfDirectProduct( D000, 1 );
    p32 := ProjectionInFactorOfDirectProduct( D000, 2 );
    p33 := ProjectionInFactorOfDirectProduct( D000, 3 );
    
    B2 := List( N0N0N0,
                i -> DirectProduct(
                        HomomorphismStructureOnObjects( B0[1 + p31( i )], B0[1 + p32( i )] ),
                        HomomorphismStructureOnObjects( B0[1 + p32( i )], B0[1 + p33( i )] ) ) );
    
    N2 := Coproduct( B2 );
    
    T := TerminalObject( H );
    
    ## N1 -> N0 × N0 -> N0 × N0 × N0
    ## this is elegant but needs a justification:
    ds := PreCompose( pi2, EmbeddingOfEqualizer( [ p32, p33 ] ) );
    
    ## N1 -> N2
    is := MapOfFinSets(
                  N1,
                  List( N1,
                        i -> PreCompose(
                                DirectProductFunctorial(
                                        [ LiftAlongMonomorphism( InjectionOfCofactorOfCoproduct( B1, 1 + pi2( i ) ), MapOfFinSets( T, [ i ], N1 ) ),
                                          InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( IdentityMorphism( B0[1 + t( i )] ) ) ] ),
                                InjectionOfCofactorOfCoproduct( B2, 1 + ds( i ) ) )( 0 ) ),
                  N2 );
    
    ## N1 -> N0 × N0 -> N0 × N0 × N0
    ## this is elegant but needs a justification:
    dt := PreCompose( pi2, EmbeddingOfEqualizer( [ p31, p32 ] ) );
    
    ## N1 -> N2
    it := MapOfFinSets(
                  N1,
                  List( N1,
                        i -> PreCompose(
                                DirectProductFunctorial(
                                        [ InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( IdentityMorphism( B0[1 + s( i )] ) ),
                                          LiftAlongMonomorphism( InjectionOfCofactorOfCoproduct( B1, 1 + pi2( i ) ), MapOfFinSets( T, [ i ], N1 ) ) ] ),
                                InjectionOfCofactorOfCoproduct( B2, 1 + dt( i ) ) )( 0 ) ),
                  N2 );

    ## N0 × N0 × N0 -> N0 × N0
    p312 := UniversalMorphismIntoDirectProduct( [ p31, p32 ] );
    p323 := UniversalMorphismIntoDirectProduct( [ p32, p33 ] );
    p313 := UniversalMorphismIntoDirectProduct( [ p31, p33 ] );
    
    Assert( 0, p312 = ProjectionInFactorOfDirectProduct( [ N0N0, N0 ], 1 ) );
    Assert( 0, p323 = ProjectionInFactorOfDirectProduct( [ N0, N0N0 ], 2 ) );
    
    ## N2 -> N0 × N0 × N0
    ## this morphism is mixing two levels and is not a CAP operation:
    ## the coproduct N2 in SkeletalFinSets is taken over the index set N0N0N0 (here also realized as an object in SkeletalFinSets),
    ## so this morphism is a fibration of a coproduct over its "index set" which are both assumed to objects in the same category:
    pi3 := MapOfFinSets( N2, Concatenation( List( N0N0N0, i -> ListWithIdenticalEntries( Length( B2[1 + i] ), i ) ) ), N0N0N0 );
    
    ## N2 -> N0 × N0 × N0 -> N0 × N0
    pi312 := PreCompose( pi3, p312 );
    pi323 := PreCompose( pi3, p323 );
    pi313 := PreCompose( pi3, p313 );
    
    ## N2 -> N1
    ps := MapOfFinSets(
                  N2,
                  List( N2,
                        i -> PreCompose( [
                                LiftAlongMonomorphism( InjectionOfCofactorOfCoproduct( B2, 1 + pi3( i ) ), MapOfFinSets( T, [ i ], N2 ) ),
                                ProjectionInFactorOfDirectProduct( [ B1[1 + pi312( i )], B1[1 + pi323( i )] ], 1 ),
                                InjectionOfCofactorOfCoproduct( B1, 1 + pi312( i ) ) ] )( 0 ) ),
                  N1 );
    
    ## N2 -> N1
    pt := MapOfFinSets(
                  N2,
                  List( N2,
                        i -> PreCompose( [
                                LiftAlongMonomorphism( InjectionOfCofactorOfCoproduct( B2, 1 + pi3( i ) ), MapOfFinSets( T, [ i ], N2 ) ),
                                ProjectionInFactorOfDirectProduct( [ B1[1 + pi312( i )], B1[1 + pi323( i )] ], 2 ),
                                InjectionOfCofactorOfCoproduct( B1, 1 + pi323( i ) ) ] )( 0 ) ),
                  N1 );
    
    mus := List( N0N0N0,
                 i -> List( B2[1 + i],
                         j -> [ MapOfFinSets( T, [ ProjectionInFactorOfDirectProduct( [ B1[1 + p312( i )], B1[1 + p323( i )] ], 1 )(j) ], B1[1 + p312( i )] ),
                                MapOfFinSets( T, [ ProjectionInFactorOfDirectProduct( [ B1[1 + p312( i )], B1[1 + p323( i )] ], 2 )(j) ], B1[1 + p323( i )] ) ] ) );
    
    Assert( 0, Length( Concatenation( mus ) ) = Length( N2 ) );
    
    Assert( 0, ForAll( mus, mu -> ForAll( mu, m -> IsWellDefined( m[1] ) and IsWellDefined( m[2] ) ) ) );
    
    mus := List( N0N0N0,
                 i -> List( B2[1 + i],
                         j -> PreCompose(
                                 InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( B0[1 + p31( i )], B0[1 + p32( i )], mus[1 + i][1 + j][1] ),
                                 InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( B0[1 + p32( i )], B0[1 + p33( i )], mus[1 + i][1 + j][2] ) ) ) );
    
    mus := List( N0N0N0,
                 i -> List( B2[1 + i],
                         function( j )
                           local phi;
                           
                           phi := InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( mus[1 + i][1 + j] );
                           
                           IsWellDefined( phi );
                           
                           Assert( 0, Range( phi ) = B1[1 + p313( i )] );
                           
                           return phi;
                           
                       end ) );
    
    mus := List( N0N0N0, i -> UniversalMorphismFromCoproductWithGivenCoproduct( H, List( mus[1 + i], Source ), B1[1 + p313( i )], mus[1 + i], B2[1 + i] ) );
    
    Assert( 0, ForAll( [ 1 .. Length( N0N0N0 ) ], i -> Source( mus[i] ) = B2[i] ) );
    
    ## N2 -> N1
    mu := MapOfFinSets(
                  N2,
                  List( N2,
                        i -> PreCompose( [
                                LiftAlongMonomorphism( InjectionOfCofactorOfCoproduct( B2, 1 + pi3( i ) ), MapOfFinSets( T, [ i ], N2 ) ),
                                mus[1 + pi3( i )],
                                InjectionOfCofactorOfCoproduct( B1, 1 + pi313( i ) ) ] )( 0 ) ),
                  N1 );
    
    Nerve_ValuesOnAllObjects := rec( C0 := N0, C1 := N1, C2 := N2 );
    
    Nerve_ValuesOnAllGeneratingMorphisms :=
      rec(
          id := id,
          s := s,
          t := t,
          is := is,
          it := it,
          ps := ps,
          pt := pt,
          mu := mu
          );
    
    name := Concatenation( "Nerve of ", Name( B ) );
    
    return CapFunctor( Delta2op, Nerve_ValuesOnAllObjects, Nerve_ValuesOnAllGeneratingMorphisms );
    
end );

##
InstallMethod( YonedaNaturalEpimorphisms,
        [ IsFpCategory and HasRangeCategoryOfHomomorphismStructure ],
        
  function ( B )
    local A, objs, mors, o, m, H, D, precompose, Hom2, hom3, Hom3, sum3, emb3, iso3, inv3,
          N0, N1, N2, pt, mu, s;
    
    A := UnderlyingQuiverAlgebra( B );
    
    if not IsFiniteDimensional( A ) then
        
        Error( "The underlying quiver algebra should be finite dimensional!\n" );
        
    fi;
    
    objs := SetOfObjects( B );
    mors := SetOfGeneratingMorphisms( B );
    
    o := Length( objs );
    m := Length( mors );
    
    ## [ [ Hom(a, c) ]_{a ∈ B} ]_{c ∈ B}:
    Hom2 := List( objs,
                  c -> List( objs,
                          a -> HomomorphismStructureOnObjects( a, c ) ) );
    
    ## [ [ [ ( Hom(a, b), Hom(b, c) ) ]_{b ∈ B} ]_{a ∈ B} ]_{c ∈ B}:
    hom3 := List( [ 1 .. o ],
                  c -> List( [ 1 .. o ],
                          a -> List( [ 1 .. o ],
                                  b -> [ Hom2[b, a], Hom2[c, b] ] ) ) );
    
    ## [ [ [ Hom(a, b) × Hom(b, c) ]_{b ∈ B} ]_{a ∈ B} ]_{c ∈ B}:
    Hom3 := List( [ 1 .. o ],
                  c -> List( [ 1 .. o ],
                          a -> List( [ 1 .. o ],
                                  b -> DirectProduct( hom3[c][a, b] ) ) ) );
    
    ## [ [ Hom(a, b) × Hom(b, c) ]_{a, b ∈ B} ]_{c ∈ B}:
    sum3 := List( Hom3, L -> Concatenation( TransposedMat( L ) ) );
    
    ## The embeddings into the double coproducts
    ## [ [ [ Hom(a, b) × Hom(b, c) ↪ ⊔_{a' ∈ B} ⊔_{b' ∈ B} Hom(a', b') × Hom(b', c) ]_{b ∈ B} ]_{a ∈ B} ]_{c ∈ B}:
    emb3 := List( [ 1 .. o ],
                  c -> List( [ 1 .. o ],
                          a -> List( [ 1 .. o ],
                                  b -> InjectionOfCofactorOfCoproduct( sum3[c], o * ( b - 1 ) + a ) ) ) );
    
    ## The isomorphisms
    ## [ ⊔_{a ∈ B} ⊔_{b ∈ B} Hom(a, b) × Hom(b, c) → ⊔_{b ∈ B} ⊔_{a ∈ B} Hom(a, b) × Hom(b, c) ]_{c ∈ B}:
    iso3 := List( emb3, emb -> UniversalMorphismFromCoproduct( Concatenation( emb ) ) );
    
    H := RangeCategoryOfHomomorphismStructure( B );
    
    D := DistinguishedObjectOfHomomorphismStructure( B );
    
    ## mu_{a,b,c}: Hom(a, b) × Hom(b, c) ↠ Hom(a, c):
    precompose :=
      function ( a, b, c )
        return
          MapOfFinSets(
                  Hom3[c][a, b], # = Hom(a, b) × Hom(b, c)
                  List( Hom3[c][a, b],
                        function ( i )
                          local d, d_ab, d_bc, m_ab, m_bc, m;
                          
                          ## D → Hom(a, b) × Hom(b, c):
                          d := MapOfFinSets( D, [ i ], Hom3[c][a, b] );
                          
                          ## D → Hom(a, b) × Hom(b, c) → Hom(a, b):
                          d_ab := PreCompose( d, ProjectionInFactorOfDirectProduct( hom3[c][a, b], 1 ) );
                          
                          ## D → Hom(a, b) × Hom(b, c) → Hom(b, c):
                          d_bc := PreCompose( d, ProjectionInFactorOfDirectProduct( hom3[c][a, b], 2 ) );
                          
                          ## the map a → b corresponding to d_ab:
                          m_ab := InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( objs[a], objs[b], d_ab );
                          
                          ## the map b → c corresponding to d_bc:
                          m_bc := InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( objs[b], objs[c], d_bc );
                          
                          ## the composition a → b → c:
                          m := PreCompose( m_ab, m_bc );
                          
                          ## reinterpret the composition m as a morphism D → Hom(a, c),
                          ## then get its number as an element in Hom(a, c):
                          return InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( m )( 0 );
                          
                      end ),
                  Hom2[c, a] ); # = Hom(a, c)
    end;
    
    ## The constant functor of 0-cells B → H, c ↦ B_0, ψ ↦ id_{B_0}
    N0 := CapFunctor( B, FinSet( H, o ) );
    
    ## The Yoneda functor B → H, c ↦ Hom(-, c), ψ ↦ Hom(-, ψ), where
    ## Hom(-, c) := ⊔_{a ∈ B} Hom(a, c),
    ## Hom(-, ψ) := ⊔_{a ∈ B} Hom(id_a, ψ):
    N1 := CapFunctor(
                  B,
                  List( [ 1 .. o ], c ->
                        ## Hom(-, c) := ⊔_{a ∈ B} Hom(a, c):
                        Coproduct( Hom2[c] ) ),
                  List( mors, psi ->
                        ## Hom(-, ψ) := ⊔_{a ∈ B} Hom(id_a, ψ):
                        CoproductFunctorial(
                                List( objs, a -> HomStructure( a, psi ) ) ) ),
                  H );
    
    ## The 2-Yoneda functor B → H, c ↦ Hom(-, -) × Hom(-, c) and ψ ↦ Hom(-, -) × Hom(-, ψ), where
    ## Hom(-, -) × Hom(-, c) := ⊔_{a ∈ B} ⊔_{b ∈ B} Hom(a, b) × Hom(b, c),
    ## Hom(-, -) × Hom(-, ψ) := ⊔_{a ∈ B} ⊔_{b ∈ B} Hom(id_a, id_b) × Hom(id_b, ψ):
    N2 := CapFunctor(
                  B,
                  List( [ 1 .. o ], c ->
                        ## Hom(-, -) × Hom(-, c) := ⊔_{a ∈ B} ⊔_{b ∈ B} Hom(a, b) × Hom(b, c):
                        Coproduct( Concatenation( Hom3[c] ) ) ),
                  List( mors, psi ->
                        ## Hom(-, -) × Hom(-, ψ) := ⊔_{a ∈ B} ⊔_{b ∈ B} Hom(id_a, id_b) × Hom(id_b, ψ):
                        CoproductFunctorial(
                                Concatenation(
                                        List( objs, a ->
                                              List( objs, b ->
                                                    ## Hom(id_a, id_b) × Hom(id_b, ψ):
                                                    DirectProductFunctorial(
                                                              [ HomStructure( IdentityMorphism( a ), IdentityMorphism( b ) ),
                                                                HomStructure( IdentityMorphism( b ), psi ) ] ) ) ) ) ) ),
                  H );
    
    ## The Yoneda projection is a natrual epimorphism from the 2-Yoneda functor to the Yoneda functor
    ## B → H, c ↦ Hom(-, -) × Hom(-, c) and ψ ↦ Hom(-, -) × Hom(-, ψ)
    pt := NaturalTransformation(
                  N2, ## The 2-Yoneda functor: B → H, c ↦ Hom(-, -) × Hom(-, c) and ψ ↦ Hom(-, -) × Hom(-, ψ)
                  List( [ 1 .. o ], c ->
                        ## ⊔_{a ∈ B} ⊔_{b ∈ B} Hom(a, b) × Hom(b, c) ↠ ⊔_{b ∈ B} Hom(b, c):
                        PreCompose(
                                ## ⊔_{a ∈ B} ⊔_{b ∈ B} Hom(a, b) × Hom(b, c) → ⊔_{b ∈ B} ⊔_{a ∈ B} Hom(a, b) × Hom(b, c):
                                iso3[c],
                                ## ⊔_{b ∈ B} ⊔_{a ∈ B} Hom(a, b) × Hom(b, c) ↠ ⊔_{b ∈ B} Hom(b, c):
                                CoproductFunctorial(
                                        List( [ 1 .. o ], b ->
                                              ## ⊔_{a ∈ B} Hom(a, b) × Hom(b, c) ↠ Hom(b, c):
                                              UniversalMorphismFromCoproduct(
                                                      List( [ 1 .. o ], a ->
                                                            ## Hom(a, b) × Hom(b, c) ↠ Hom(b, c):
                                                            ProjectionInFactorOfDirectProduct( hom3[c][a, b], 2 ) ) ) ) ) ) ),
                  N1 ); ## The Yoneda functor B → H, c ↦ Hom(-, c), ψ ↦ Hom(-, ψ)
    
    SetIsEpimorphism( pt, true );
    
    ## The Yoneda composition is a natrual epimorphism from the 2-Yoneda functor to the Yoneda functor
    ## Hom(-, -) × Hom(-, c) ↠ Hom(-, c):
    mu := NaturalTransformation(
                  N2, ## The 2-Yoneda functor: B → H, c ↦ Hom(-, -) × Hom(-, c) and ψ ↦ Hom(-, -) × Hom(-, ψ)
                  List( [ 1 .. o ], c ->
                        ## ⊔_{a ∈ B} ⊔_{b ∈ B} Hom(a, b) × Hom(b, c) ↠ ⊔_{a ∈ B} Hom(a, c):
                        CoproductFunctorial(
                                List( [ 1 .. o ], a ->
                                      ## ⊔_{b ∈ B} Hom(a, b) × Hom(b, c) ↠ Hom(a, c):
                                      UniversalMorphismFromCoproduct(
                                              List( [ 1 .. o ], b ->
                                                    ## Hom(a, b) × Hom(b, c) ↠ Hom(a, c):
                                                    precompose( a, b, c ) ) ) ) ) ),
                  N1 ); ## The Yoneda functor B → H, c ↦ Hom(-, c), ψ ↦ Hom(-, ψ)
    
    SetIsEpimorphism( mu, true );
    
    ## The source fibration is a natrual morphism from the Yoneda functor to the constant functor of 0-cells
    ## Hom(-, c) → B_0:
    s := NaturalTransformation(
                 N1, ## The Yoneda functor B → H, c ↦ Hom(-, c), ψ ↦ Hom(-, ψ)
                 List( [ 1 .. o ], c ->
                       ## ⊔_{a ∈ B} Hom(a, c) → B_0, ϕ ↦ Source(ϕ)
                       CoproductFunctorial(
                               List( [ 1 .. o ], a ->
                                     ## Hom(a, c) → {a}, ϕ ↦ a
                                     UniversalMorphismIntoTerminalObject( Hom2[c, a] ) ) ) ),
                 N0 ); ## The constant functor of 0-cells
    
    return [ pt, mu, s ];
    
end );

##
InstallMethod( YonedaProjectionAsNaturalEpimorphism,
        [ IsFpCategory and HasRangeCategoryOfHomomorphismStructure ],
        
  function ( B )
    
    return YonedaNaturalEpimorphisms( B )[1];
    
end );

##
InstallMethod( YonedaCompositionAsNaturalEpimorphism,
        [ IsFpCategory and HasRangeCategoryOfHomomorphismStructure ],
        
  function ( B )
    
    return YonedaNaturalEpimorphisms( B )[2];
    
end );

##
InstallMethod( YonedaFibrationAsNaturalTransformation,
        [ IsFpCategory and HasRangeCategoryOfHomomorphismStructure ],
        
  function ( B )
    
    return YonedaNaturalEpimorphisms( B )[3];
    
end );

##
InstallMethod( TruthMorphismOfTrueToSieveFunctorAndEmbedding,
        [ IsFpCategory ],
        
  function ( B )
    local Bop, H, D, Omega, Ymu, Ypt, sieves, actions, psi,
          Sieves, Sieves_emb, Sieves_maximal, c, Sieves_objects, Sieves_morphisms, Sieves_functor,
          HomHomOmega_objects, HomHomOmega_morphisms, HomHomOmega_functor;
    
    Bop := OppositeFpCategory( B );
    
    H := RangeCategoryOfHomomorphismStructure( B );
    
    D := DistinguishedObjectOfHomomorphismStructure( B );
    
    Omega := SubobjectClassifier( H );
    
    Ypt := YonedaProjectionAsNaturalEpimorphism( B );
    Ymu := YonedaCompositionAsNaturalEpimorphism( B );
    
    sieves :=
      function ( c )
        local pt_c, mu_c, hom_c, power, action, maximal, emb;
        
        ## Hom(-, -) × Hom(-, c) ↠ Hom(-, c)
        pt_c := Ypt( c );
        
        ## Hom(-, -) × Hom(-, c) ↠ Hom(-, c)
        mu_c := Ymu( c );
        
        ## Hom(-, c) := ⊔_{a ∈ B} Hom(a, c)
        hom_c := Range( mu_c );
        
        ## Hom(Hom(-, c), Ω) := Hom(⊔_{a ∈ B} Hom(a, c), Ω)
        power := HomStructure( hom_c, Omega );
        
        ## define the action as an endomorphism on Hom(Hom(-, c), Ω)
        action :=
          MapOfFinSets(
                  power, ## Hom(Hom(-, c), Ω)
                  List( power, i ->
                        ## interpreted as an "element" D → Hom(Hom(-, c), Ω)
                        InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure(
                                ## interpreted as a classifying morphism χ_{s'}: Hom(-, c) → Ω
                                ClassifyingMorphismOfSubobject(
                                        ## s' ↪ Hom(-, c)
                                        ImageEmbedding(
                                                ## Hom(-, -) × s → Hom(-, c)
                                                PreCompose(
                                                        ## Hom(-, -) × s ↪ Hom(-, -) × Hom(-, c)
                                                        ProjectionInFactorOfFiberProduct(
                                                                [ pt_c,
                                                                  ## interpreted as a subobject s ↪ Hom(-, c)
                                                                  SubobjectOfClassifyingMorphism(
                                                                          ## interpreted as a  classifying morphism χ_s: Hom(-, c) → Ω
                                                                          InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism(
                                                                                  hom_c,
                                                                                  Omega,
                                                                                  ## an "element" D → Hom(Hom(-, c), Ω)
                                                                                  MapOfFinSets( D, [ i ], power ) ) )
                                                                  ], 1 ),
                                                        ## μ_c: Hom(-, -) × Hom(-, c) ↠ Hom(-, c)
                                                        mu_c ) ) ) )( 0 ) ),
                  power ); ## Hom(Hom(-, c), Ω)
        
        ## The sieves on c are the fixed points of the above action on Hom(Hom(-, c), Ω),
        ## resulting in the embedding Sieves(c) ↪ Hom(Hom(-, c), Ω):
        emb := EmbeddingOfEqualizer( [ action, IdentityMorphism( power ) ] );
        
        ## the "element" D → Sieves(c) corresponding to the maximal sieve:
        maximal := LiftAlongMonomorphism(
                           ## Sieves(c) ↪ Hom(Hom(-, c), Ω):
                           emb,
                           ## interpreted as an "element" D → Hom(Hom(-, c), Ω)
                           InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure(
                                   ## the corresponding classifying morphism χ: Hom(-, c) → Ω
                                   ClassifyingMorphismOfSubobject(
                                           ## id: Hom(-, c) → Hom(-, c)
                                           IdentityMorphism( hom_c ) ) ) );
        
        return [ emb, maximal ];
        
    end;
    
    actions := rec( );
    
    for psi in SetOfGeneratingMorphisms( B ) do
        actions.(StringView( psi )) := HomStructure( Range( Ypt )( psi ), Omega );
    od;
    
    Sieves := rec( );
    Sieves_emb := rec( );
    Sieves_maximal := rec( );
    
    for c in SetOfObjects( B ) do
        Sieves.(String( UnderlyingVertex( c ) )) := sieves( c );
        Sieves_emb.(String( UnderlyingVertex( c ) )) := Sieves.(String( UnderlyingVertex( c ) ))[1];
        Sieves_maximal.(String( UnderlyingVertex( c ) )) := Sieves.(String( UnderlyingVertex( c ) ))[2];
    od;
    
    Sieves_objects :=
      List( SetOfObjects( B ),
            c -> Source( Sieves_emb.(String( UnderlyingVertex( c ) )) ) );
    
    Sieves_morphisms :=
      List( SetOfGeneratingMorphisms( B ),
            psi -> LiftAlongMonomorphism(
                    Sieves_emb.(String( UnderlyingVertex( Source( psi ) ) )),
                    PreCompose(
                            Sieves_emb.(String( UnderlyingVertex( Range( psi ) ) )),
                            actions.(StringView( psi )) ) ) );
    
    Sieves_functor := CapFunctor( Bop, Sieves_objects, Sieves_morphisms, H );
    
    ## Hom(Hom(-, c), Ω)
    HomHomOmega_objects :=
      List( SetOfObjects( B ),
            c -> Range( Sieves_emb.(String( UnderlyingVertex( c ) )) ) );
    
    HomHomOmega_morphisms :=
      List( SetOfGeneratingMorphisms( B ),
            psi -> actions.(StringView( psi )) );
    
    HomHomOmega_functor := CapFunctor( Bop, HomHomOmega_objects, HomHomOmega_morphisms, H );
    
    return [ ## T → Sieves, c ↦ ( T(c) = {*} → Sieves(c), * ↦ maximal_sieve(c) := Hom(-, c) )
             NaturalTransformation(
                   Sieves_maximal,
                   CapFunctor( Bop,
                           ListWithIdenticalEntries( Length( SetOfObjects( B ) ), D ),
                           ListWithIdenticalEntries( Length( SetOfGeneratingMorphisms( B ) ), IdentityMorphism( D ) ),
                           H ),
                   Sieves_functor ),
             ## Sieves → Hom(Hom(-, c), Ω), c ↦ ( Sieves(c) ↪ Hom(Hom(-, c), Ω), s ↦ s )
             NaturalTransformation(
                     Sieves_emb,
                     Sieves_functor,
                     HomHomOmega_functor ) ];
    
end );

##
InstallMethod( TruthMorphismOfTrueToSieveFunctor,
        [ IsFpCategory ],
        
  function ( B )
    
    return TruthMorphismOfTrueToSieveFunctorAndEmbedding( B )[1];
    
end );

##
InstallMethod( SieveFunctor,
        [ IsFpCategory ],
        
  function ( B )
    
    return Range( TruthMorphismOfTrueToSieveFunctor( B ) );
    
end );

##
InstallMethod( EmbeddingOfSieveFunctor,
        [ IsFpCategory ],
        
  function ( B )
    
    return TruthMorphismOfTrueToSieveFunctorAndEmbedding( B )[2];
    
end );

####################################
#
# methods for properties:
#
####################################

##
InstallMethod( IsCommutative,
        "for an FpCategory",
        [ IsFpCategory ],
     
  function( A )
    local arrows, i, j;
    
    arrows := Arrows( UnderlyingQuiverAlgebra( A ) );
    
    for i in [ 1 .. Length( arrows ) ] do
      for j in [ (i+1) .. Length( arrows ) ] do
        if not arrows[i] * arrows[j] = arrows[j] * arrows[i] then
          return false;
        fi;
      od;
    od;
    
    return true;
    
end );

####################################
#
# View, Print, and Display methods:
#
####################################

##
InstallMethod( ViewObj,
        "for an object in a f.p. category",
        [ IsObjectInFpCategory ],
        
  function( o )
    
    Print( "<", StringView( UnderlyingVertex( o ) ), ">" );
    
end );

##
InstallMethod( ViewObj,
        "for a morphism in a f.p. category",
        [ IsMorphismInFpCategory ],
        
  function( o )
    
    if IsRightQuiverAlgebra( UnderlyingQuiverAlgebra( CapCategory( o ) ) ) then
        ViewObj( UnderlyingVertex( Source( o ) ) );
        Print( "-[" );
        ViewObj( Paths( UnderlyingQuiverAlgebraElement( o ) )[1] );
        Print( "]->" );
        ViewObj( UnderlyingVertex( Range( o ) ) );
    else
        ViewObj( UnderlyingVertex( Range( o ) ) );
        Print( "<-[" );
        ViewObj( Paths( UnderlyingQuiverAlgebraElement( o ) )[1] );
        Print( "]-" );
        ViewObj( UnderlyingVertex( Source( o ) ) );
    fi;
    
end );

##
InstallMethod( LaTeXStringOp,
          [ IsObjectInFpCategory ],
          
  o -> LaTeXStringForQPA( UnderlyingVertex( o ) )
);

##
InstallMethod( LaTeXOutput,
          [ IsObjectInFpCategory ],
          
  LaTeXStringOp
);

##
InstallMethod( LaTeXStringOp,
          [ IsMorphismInFpCategory ],
          
  function( m )
    local s;
    
    s := LaTeXStringForQPA( UnderlyingQuiverAlgebraElement( m ) );
    
    if ValueOption( "OnlyDatum" ) = true then
      
      return s;
      
    else
      
      return Concatenation(
                "{", LaTeXOutput( Source( m ) ), "}-\\left(",
                "{", s, "}\\right)\\rightarrow",
                "{", LaTeXOutput( Range( m ) ), "}"
              );
              
    fi;
    
end );

##
InstallMethod( LaTeXOutput,
          [ IsMorphismInFpCategory ],
          
  LaTeXStringOp
);
