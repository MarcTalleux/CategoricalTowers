#
# Bialgebroids: Algebroids as preadditive categories generated by enhanced quivers
#
# Implementations
#

####################################
#
# representations:
#
####################################

DeclareRepresentation( "IsCapCategoryObjectInAlgebroidRep",
        IsCapCategoryObjectInAlgebroid and
        IsAttributeStoringRep,
        [ ] );

DeclareRepresentation( "IsCapCategoryMorphismInAlgebroidRep",
        IsCapCategoryMorphismInAlgebroid and
        IsAttributeStoringRep,
        [ ] );

####################################
#
# methods for attributes:
#
####################################

InstallMethodWithCache( CategoryOfAlgebroids,
               [ IsHomalgRing, IsString ],
               
  function( homalg_ring, parity )
    local category;
    
    category := CreateCapCategory( Concatenation( "(", parity, ") Algebroids( ", RingName( homalg_ring )," )"  ) );
    
    SetFilterObj( category, IsCategoryOfAlgebroids );
    
    SetUnderlyingRing( category, homalg_ring );
    
    SetParity( category, parity );
    
    AddObjectRepresentation( category, IsCategoryOfAlgebroidsObject );
    
    AddMorphismRepresentation( category, IsCategoryOfAlgebroidsMorphism );

    INSTALL_FUNCTIONS_FOR_CATEGORY_OF_ALGEBROIDS( category );
    
    Finalize( category );
    
    return category;
    
end );

##
InstallMethod( SetOfObjects,
        "for an algebroid",
        [ IsAlgebroid and HasUnderlyingQuiver ],
        
  A -> List( Vertices( UnderlyingQuiver( A ) ), o -> A.( String( o ) ) ) );

##
InstallMethod( AssignSetOfObjects,
        [ IsAlgebroid and HasUnderlyingQuiver, IsString ],
  function( A, label )
    local names, objects, func;
    
    names := List( Vertices( UnderlyingQuiver( A ) ), String );
    
    objects := SetOfObjects( A );
    
    func := function( name, o )
              
              if Int( name ) <> fail and label = "" then
                  Error( "The second argument should be a non-empty string" );
              fi;
              
              name := Concatenation( label, ReplacedString( name, "-", "m" ) );
              
              MakeReadWriteGlobal( name );
              
              DeclareSynonym( name, o );
              
              return 1;
              
            end;
            
    ListN( names, objects, func );
    
end );

##
InstallOtherMethod( AssignSetOfObjects,
        [ IsAlgebroid and HasUnderlyingQuiver ],
  function( A )
  
    AssignSetOfObjects( A, "" );
    
end );

##
InstallMethod( SetOfGeneratingMorphisms,
        "for an algebroid",
        [ IsAlgebroid and HasUnderlyingQuiver ],
        
  A -> List( Arrows( UnderlyingQuiver( A ) ), o -> A.(String( o ) ) ) );

##
InstallMethodWithCache( SetOfGeneratingMorphisms,
        "for and algebroid and two objects",
        [ IsAlgebroid and HasUnderlyingQuiver, IsCapCategoryObjectInAlgebroid, IsCapCategoryObjectInAlgebroid ],
        
  { A, obj_1, obj_2 } -> Filtered( SetOfGeneratingMorphisms( A ), m -> IsEqualForObjects( obj_1, Source( m ) ) and IsEqualForObjects( obj_2, Range( m ) ) )
);

##
InstallMethod( SetOfGeneratingMorphisms,
        "for two objects in an algebroid",
         [ IsCapCategoryObjectInAlgebroid, IsCapCategoryObjectInAlgebroid ],
         
  { obj_1, obj_2 } -> SetOfGeneratingMorphisms( CapCategory( obj_1 ), obj_1, obj_2 )
);

##
InstallMethodWithCache( SetOfGeneratingMorphisms,
        "for and algebroid and two integers",
        [ IsAlgebroid and HasUnderlyingQuiver, IsInt, IsInt ],
        
  { A, i, j } -> SetOfGeneratingMorphisms( A, SetOfObjects( A )[ i ], SetOfObjects( A )[ j ] )
);

##
InstallMethod( AssignSetOfGeneratingMorphisms,
        [ IsAlgebroid and HasUnderlyingQuiver, IsString ],
  function( A, label )
    local names, morphisms, func;
    
    names := List( Arrows( UnderlyingQuiver( A ) ), String );
    
    morphisms := SetOfGeneratingMorphisms( A );
    
    func := function( name, m )
              
              if Int( name ) <> fail and label = "" then
                  Error( "The second argument should be a non-empty string" );
              fi;
              
              name := Concatenation( label, ReplacedString( name, "-", "m" ) );
              
              MakeReadWriteGlobal( name );
              
              DeclareSynonym( name, m );
              
              return 1;
              
            end;
            
    ListN( names, morphisms, func );
    
end );

##
InstallOtherMethod( AssignSetOfGeneratingMorphisms,
        [ IsAlgebroid and HasUnderlyingQuiver ],
  function( A )
    
    AssignSetOfGeneratingMorphisms( A, "" );
    
end );


##
InstallMethod( RelationsOfAlgebroid,
        "for an algebroid",
        [ IsAlgebroid and HasUnderlyingQuiverAlgebra ],
        
  function( A )
    local relations;
    
    relations := RelationsOfAlgebra( UnderlyingQuiverAlgebra( A ) );
    
    relations := Filtered( relations, r -> not IsZero( r ) );
    
    return List( relations, MorphismInAlgebroid );
    
end );

##
InstallMethod( BijectionBetweenPairsAndElementaryTensors,
        "for a QPA quiver algebra",
        [ IsQuiverAlgebra ],
        
  function( Qq )
    local Qqq, gens, prod;
    
    if HasPathAlgebra( Qq ) then
        Qq := PathAlgebra( Qq );
    fi;
    
    Qqq := TensorProductOfAlgebras( Qq, Qq );
    
    gens := PrimitivePaths( QuiverOfAlgebra( Qq ) );
    
    gens := Cartesian( gens, gens );
    
    prod := List( gens,
                  p -> ElementaryTensor(
                          PathAsAlgebraElement( Qq, p[1] ),
                          PathAsAlgebraElement( Qq, p[2] ),
                          Qqq ) );
    
    
    prod := List( prod, a -> Paths( Representative( a ) )[1] );
    
    return [ prod, gens ];
    
end );

##
InstallMethod( DecompositionOfMorphismInAlgebroid,
        "for a morphism in an algebroid",
        [ IsCapCategoryMorphismInAlgebroidRep ],
        
  function( mor )
    local B, func;
    
    B := CapCategory( mor );
    
    mor := UnderlyingQuiverAlgebraElement( mor );
    
    mor := DecomposeQuiverAlgebraElement( mor );
    
    func :=
      function( a )
        return List( a,
                     function( f )
                       f := B.(String( f ));
                       if IsCapCategoryObject( f ) then
                           return IdentityMorphism( f );
                       fi;
                       return f;
                     end );
        
      end;
    
    mor[2] := List( mor[2], func );
    
    return ListN( mor[1], mor[2], function( r, s ) return [ r, s ]; end );
    
end );

##
InstallMethod( DecompositionOfMorphismInSquareOfAlgebroid,
        "for a morphism in an algebroid",
        [ IsCapCategoryMorphismInAlgebroidRep ],
        
  function( mor )
    local B, Rq, gens, prod, func;
    
    B := CapCategory( mor )!.PowerOf;
    
    Rq := UnderlyingQuiverAlgebra( B );
    
    gens := BijectionBetweenPairsAndElementaryTensors( Rq );
    prod := gens[2];
    gens := gens[1];
    
    mor := UnderlyingQuiverAlgebraElement( mor );
    
    mor := DecomposeQuiverAlgebraElement( mor );
    
    mor[2] := List( mor[2], p -> List( p, a -> prod[Position( gens, a )] ) );
    
    func :=
      function( a )
        return List( a,
                     function( f )
                       f := B.(String( f ));
                       if IsCapCategoryObject( f ) then
                           return IdentityMorphism( f );
                       fi;
                       return f;
                     end );
        
      end;
    
    mor[2] := List( mor[2], p -> List( p, func ) );
    
    return ListN( mor[1], mor[2], function( r, s ) return [ r, s ]; end );
    
end );

####################################
#
# methods for operation:
#
####################################

InstallGlobalFunction( INSTALL_FUNCTIONS_FOR_CATEGORY_OF_ALGEBROIDS,
  
  function( category )
    local ring, parity;
    
    ring := UnderlyingRing( category );
    parity := Parity( category );

    ##
    AddIsEqualForCacheForObjects( category,
      IsIdenticalObj );
    
    ##
    AddIsEqualForCacheForMorphisms( category,
      IsIdenticalObj );
    
    ## Equality Basic Operations for Objects and Morphisms
    ##
    AddIsEqualForObjects( category,
      function( object_1, object_2 )
      
        return UnderlyingQuiverAlgebra( AsCapCategory ( object_1 ) )
               = UnderlyingQuiverAlgebra( AsCapCategory ( object_2 ) );
       
    end );
    
    ##
    AddIsCongruentForMorphisms( category,
      function( morphism_1, morphism_2 )
        local source1, morphism_1_underlying_functor, morphism_2_underlying_functor, objects_in_source1, morphisms_in_source1, o, m;
        
        source1 := AsCapCategory( Source( morphism_1 ) );

        morphism_1_underlying_functor := AsCapFunctor( morphism_1 );
        morphism_2_underlying_functor := AsCapFunctor( morphism_2 );
        
        objects_in_source1 := SetOfObjects( source1 );

        for o in objects_in_source1 do
            if not IsEqualForObjects( ApplyFunctor( morphism_1_underlying_functor, o ),
                                      ApplyFunctor( morphism_2_underlying_functor, o ) ) then
                return false;
            fi;
        od;
        
        morphisms_in_source1 := SetOfGeneratingMorphisms( source1 );
        
        for m in morphisms_in_source1 do
            if not IsCongruentForMorphisms( ApplyFunctor( morphism_1_underlying_functor, m ),
                                        ApplyFunctor( morphism_2_underlying_functor, m ) ) then
                return false;
            fi;
        od;

        return true;
        
    end );
    
    ## Basic Operations for a Category
    ##
    AddIdentityMorphism( category,
      
      function( object )
        
        return CategoryOfAlgebroidsMorphism( object, IdentityFunctor( AsCapCategory( object ) ), object );
        
    end );
    
    AddPreCompose( category,
        function( morphism_1, morphism_2 )
            local composition;
            
            composition := PreCompose( AsCapFunctor(morphism_1), AsCapFunctor(morphism_2) );

            SetFilterObj( composition, IsAlgebroidMorphism );
            
            return CategoryOfAlgebroidsMorphism( Source( morphism_1 ), composition, Range( morphism_2 ) );
            
           end
    );
    
    AddTensorProductOnObjects( category,
        function( object_1, object_2 )
            return CategoryOfAlgebroidsObject( TensorProductOnObjects( AsCapCategory(object_1), AsCapCategory(object_2) ) );
        end
    );

    AddTensorProductOnMorphismsWithGivenTensorProducts( category,
        function( source_1_x_source_2, morphism_1, morphism_2, range_1_x_range_2 )
            return CategoryOfAlgebroidsMorphism( source_1_x_source_2, TensorProductOnMorphisms(AsCapFunctor( morphism_1), AsCapFunctor(morphism_2) ), range_1_x_range_2 );
        end
    );
    
    AddTensorUnit( category,
        function()
            return CategoryOfAlgebroidsObject( TrivialAlgebroid( ring, parity ) );
        end
    );

    AddLeftUnitorWithGivenTensorProduct( category,
        function(a, 1_otimes_a)
            return CategoryOfAlgebroidsMorphism( LeftUnitorAsFunctor( AsCapCategory( a ) ) );
        end
    );

    AddLeftUnitorInverseWithGivenTensorProduct( category,
        function(a, 1_otimes_a)
            return CategoryOfAlgebroidsMorphism( LeftUnitorInverseAsFunctor( AsCapCategory( a ) ) );
        end
    );
    
    AddRightUnitorWithGivenTensorProduct( category,
        function(a, a_otimes_1)
            return CategoryOfAlgebroidsMorphism( RightUnitorAsFunctor( AsCapCategory( a ) ) );
        end
    );
    
    AddRightUnitorInverseWithGivenTensorProduct( category,
        function(a, a_otimes_1)
            return CategoryOfAlgebroidsMorphism( RightUnitorInverseAsFunctor( AsCapCategory( a ) ) );
        end
    );

    AddAssociatorLeftToRightWithGivenTensorProducts( category,
        function( AxB_C, A, B, C, A_BxC )
            local AxB_C_as_category, A_as_category, B_as_category, C_as_category, A_BxC_as_category;
            
            AxB_C_as_category := AsCapCategory( AxB_C );
            A_as_category := AsCapCategory( A );
            B_as_category := AsCapCategory( B );
            C_as_category := AsCapCategory( C );
            A_BxC_as_category := AsCapCategory( A_BxC );

            return CategoryOfAlgebroidsMorphism( AssociatorLeftToRightWithGivenTensorProductsAsFunctor( AxB_C_as_category, A_as_category, B_as_category, C_as_category, A_BxC_as_category ) );
        end
    );

    AddAssociatorRightToLeftWithGivenTensorProducts( category, 
        function( A_BxC, A, B, C, AxB_C )
            local AxB_C_as_category, A_as_category, B_as_category, C_as_category, A_BxC_as_category;
            A_BxC_as_category := AsCapCategory( A_BxC );
            A_as_category := AsCapCategory( A );
            B_as_category := AsCapCategory( B );
            C_as_category := AsCapCategory( C );
            AxB_C_as_category := AsCapCategory( AxB_C );

            return CategoryOfAlgebroidsMorphism( AssociatorRightToLeftWithGivenTensorProductsAsFunctor( A_BxC_as_category, A_as_category, B_as_category, C_as_category, AxB_C_as_category ) );
        end
    );

    
end );
##
InstallMethod( DecomposeQuiverAlgebraElement,
        "for a quiver algebra element",
        [ IsQuiverAlgebraElement ],
        
  function( p )
    
    if IsQuotientOfPathAlgebraElement( p ) then
        p := Representative( p );
    fi;
    
    return [ Coefficients( p ),
             List( Paths( p ),
                   function( a )
                     if Length( a ) = 0 then
                         return [ a ];
                     fi;
                     return ArrowList( a );
                   end ) ];
    
end );

##
InstallMethod( ApplyToQuiverAlgebraElement,
        "for an object function, a morphism function, a category, a quiver algebra element and a boolean",
        [ IsFunction, IsFunction, IsCapCategory, IsQuiverAlgebraElement, IsBool ],
        
  function( object_func, morphism_func, range_category, p, contravariant )
    local applyF, paths, paths_final;
    
    # function to be applied to an arrow (or a vertex representing the trivial path at this vertex)
    applyF :=
      function( b )
        local m;
        
        if IsQuiverVertex( b ) then
            m := object_func( b );
            return IdentityMorphism( m );
        fi;
        
        return morphism_func( b );
        
    end;
    
    paths := DecomposeQuiverAlgebraElement( p )[2];
    
    if contravariant = false then
        paths_final := List( paths, a -> PreCompose( List( a, applyF ) ) );
    else
        paths_final := List( paths, a -> PreCompose( Reversed( List( a, applyF ) ) ) );
    fi;
    
    return PreCompose( paths_final );
    
end );

##
InstallMethod( ApplyToQuiverAlgebraElement,
        "for an object function, a morphism function, a linear category, a quiver algebra element, and a boolean",
        [ IsFunction, IsFunction, IsCapCategory and IsLinearCategoryOverCommutativeRing, IsQuiverAlgebraElement, IsBool ],
        
  function( object_func, morphism_func, range_category, p, contravariant )
    local applyF, paths, coefs, paths_final, s, all_objects_in_image;
    
    # function to be applied to an arrow (or a vertex representing the trivial path at this vertex)
    applyF :=
      function( b )
        local m;
        
        if IsQuiverVertex( b ) then
            m := object_func( b );
            return IdentityMorphism( m );
        fi;
        
        return morphism_func( b );
        
    end;
      
    paths := DecomposeQuiverAlgebraElement( p );
    
    coefs := paths[1];
    paths := paths[2];
    
    if contravariant = false then
        paths_final := List( paths, a -> PreCompose( List( a, applyF ) ) );
    else
        paths_final := List( paths, a -> PreCompose( Reversed( List( a, applyF ) ) ) );
    fi;
    
    if Length( coefs ) > 0 then
        s := Sum( ListN( coefs, paths_final, function( r, p ) return r * p; end ) );
    else
        all_objects_in_image := SetOfObjects( range_category );
        s := Sum( List( all_objects_in_image, o -> ZeroMorphism(o,o)) );
    fi;
    
    return s;
    
end );

##
InstallMethod( ApplyToQuiverAlgebraElement,
        "for a record (of images of objects), a record (of images of morphisms) and a quiver algebra element",
        [ IsRecord, IsRecord, IsQuiverAlgebraElement, IsBool ],
  
  function( F_objects, F_morphisms, p, contravariant )
    local func_obj, func_mor, eval_F_objects, some_object_in_image;
    
    func_obj := b -> F_objects.(String( b ));
    func_mor := b -> F_morphisms.(String( b ));
    
    some_object_in_image := List( RecNames(F_objects), func_obj )[1];

    return ApplyToQuiverAlgebraElement( func_obj, func_mor, CapCategory(some_object_in_image), p, contravariant );
    
end );

##
InstallMethod( ApplyToQuiverAlgebraElement,
        "for a functor and a quiver algebra element",
        [ IsCapFunctor, IsQuiverAlgebraElement ],

  function( functor, p )
    local func, b;
    
    func := b -> ApplyFunctor( functor, AsCapCategory(Source(functor)).(String(b)) );
    
    if IsBound( functor!.IsContravariant ) and functor!.IsContravariant then
        return ApplyToQuiverAlgebraElement( func, func, AsCapCategory(Range(functor)), p, true );
    else
        return ApplyToQuiverAlgebraElement( func, func, AsCapCategory(Range(functor)), p, false );
    fi;
end );

####################################
#
# methods for constructors:
#
####################################

##
InstallGlobalFunction( ADD_FUNCTIONS_FOR_ALGEBROID,
  
  function( category, over_Z )
    
    ##
    AddIsWellDefinedForObjects( category,
      function( o )
        
        o := UnderlyingVertex( o );
        
        return IsQuiverVertex( o ) and IsIdenticalObj( QuiverOfPath( o ), UnderlyingQuiver( category ) );
        
      end );
    
    ##
    AddIsWellDefinedForMorphisms( category,
      function( alpha )
        local m, v, w;
        
        m := UnderlyingQuiverAlgebraElement( alpha );
        
        if not IsIdenticalObj( AlgebraOfElement( m ), UnderlyingQuiverAlgebra( category ) ) then
            
            return false;
            
        fi;
        
        if IsZero( m ) then
            
            return true;
            
        fi;
        
        if not IsUniform( m ) then
            
            return false;
            
        fi;
        
        if IsQuotientOfPathAlgebraElement( m ) then
            
            m := Representative( m );
            
        fi;
        
        v := Source( LeadingPath( m ) ); 
        
        if not ( UnderlyingVertex( Source( alpha ) ) = v ) then
            
            return false;
            
        fi;
        
        w := Target( LeadingPath( m ) );
        
        if not ( UnderlyingVertex( Range( alpha ) ) = w ) then
            
            return false;
            
        fi;
        
        # all tests passed, so it is well-defined
        return true;
        
      end );
    
    ##
    AddIsEqualForObjects( category,
      function( object_1, object_2 )
        
        return UnderlyingVertex( object_1 ) = UnderlyingVertex( object_2 );
        
    end );
    
    ##
    AddIsEqualForMorphisms( category,
      function( morphism_1, morphism_2 )
        
        return UnderlyingQuiverAlgebraElement( morphism_1 ) = UnderlyingQuiverAlgebraElement( morphism_2 );
        
    end );
    
    ##
    AddIsCongruentForMorphisms( category,
      function( morphism_1, morphism_2 )
        
        return UnderlyingQuiverAlgebraElement( morphism_1 ) = UnderlyingQuiverAlgebraElement( morphism_2 );
        
    end );
    
    ##
    AddIdentityMorphism( category,
      function( object )
        local quiver_algebra, id;
        
        quiver_algebra := UnderlyingQuiverAlgebra( CapCategory( object ) );
        
        id := PathAsAlgebraElement( quiver_algebra, UnderlyingVertex( object ) );
        
        return MorphismInAlgebroid(
                       object,
                       id,
                       object );
        
    end );
    
    ##
    AddPreCompose( category,
      function( morphism_1, morphism_2 )
        local B, quiver;
        
        B := CapCategory( morphism_1 );
        
        quiver := UnderlyingQuiver( B );
        
        if IsRightQuiver( quiver ) then
            return MorphismInAlgebroid(
                           Source( morphism_1 ),
                           UnderlyingQuiverAlgebraElement( morphism_1 ) * UnderlyingQuiverAlgebraElement( morphism_2 ),
                           Range( morphism_2 ) );
        else
            return MorphismInAlgebroid(
                           Source( morphism_1 ),
                           UnderlyingQuiverAlgebraElement( morphism_2 ) * UnderlyingQuiverAlgebraElement( morphism_1 ),
                           Range( morphism_2 ) );
        fi;
        
    end );
    
    ##
    AddAdditionForMorphisms( category,
      function( morphism_1, morphism_2 )
        
        return MorphismInAlgebroid(
                       Source( morphism_1 ),
                       UnderlyingQuiverAlgebraElement( morphism_1 ) + UnderlyingQuiverAlgebraElement( morphism_2 ),
                       Range( morphism_1 ) );
        
    end );
    
    ##
    AddAdditiveInverseForMorphisms( category,
      function( morphism )
        
        return MorphismInAlgebroid(
                       Source( morphism ),
                       -UnderlyingQuiverAlgebraElement( morphism ),
                       Range( morphism ) );
        
    end );
    
    #
    AddMultiplyWithElementOfCommutativeRingForMorphisms( category,
      function( r, morphism )
        
        return MorphismInAlgebroid(
                       Source( morphism ),
                       r * UnderlyingQuiverAlgebraElement( morphism ),
                       Range( morphism ) );
        
    end );
    
    ##
    AddZeroMorphism( category,
      function( S, T )
        
        return MorphismInAlgebroid(
                       S,
                       Zero( UnderlyingQuiverAlgebra( CapCategory( S ) ) ),
                       T );
        
    end );
    
    ## only create the Hom-structure for finite dimensional quiver algebras
    if IsFiniteDimensional( UnderlyingQuiverAlgebra( category ) ) then
        
        ADD_FUNCTIONS_FOR_HOM_STRUCTURE_OF_ALGEBROID( category, over_Z );
        
        ADD_FUNCTIONS_FOR_RANDOM_METHODS_OF_ALGEBROID( category, over_Z );
        
    fi;
    
    Finalize( category );
    SetFilterObj(IdentityFunctor(category), IsAlgebroidMorphism);
    
    return category;
    
end );

InstallGlobalFunction( ADD_FUNCTIONS_FOR_HOM_STRUCTURE_OF_ALGEBROID,
    function( algebroid, over_Z )
    local quiver_algebra, quiver, vertices, basis, data, path,
          object_constructor, morphism_constructor, distinguished_object, ring, range_category;
    
    quiver_algebra := UnderlyingQuiverAlgebra( algebroid );
    
    ## Prepare quick access to basis elements
    quiver := QuiverOfAlgebra( quiver_algebra );
    
    vertices := Vertices( quiver );
    
    basis := BasisPaths( CanonicalBasis( quiver_algebra ) );
    
    data := List( vertices, i -> List( vertices, i -> [ ] ) );
    
    for path in basis do
        
        Add( data[ VertexIndex( Source( path ) ) ][ VertexIndex( Target( path ) ) ], path );
        
    od;
    
    ring := CommutativeRingOfLinearCategory( algebroid );
    
    if over_Z then
        
        range_category := CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "range_of_HomStructure", CategoryOfRows( ring ) );
        
        object_constructor := function( size )
        return CategoryOfRowsObject( size, range_category );
        end;
        
        morphism_constructor := mat -> AsCategoryOfRowsMorphism( mat, range_category );
        
        distinguished_object := function()
        return CategoryOfRowsObject( 1, range_category );
        end;
    
    else
        
        object_constructor := function( size )
        return VectorSpaceObject( size, ring );
        end;
        
        morphism_constructor := function( mat )
        return VectorSpaceMorphism(
                VectorSpaceObject( NrRows( mat ), ring ),
                mat,
                VectorSpaceObject( NrColumns( mat ), ring )
                );
        end;
        
        range_category := CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "range_of_HomStructure", MatrixCategory( ring ) );
        
        distinguished_object := function()
        return TensorUnit( range_category );
        end;
        
    fi;
    
    SetRangeCategoryOfHomomorphismStructure( algebroid, range_category );
    
    ##
    AddHomomorphismStructureOnObjects( algebroid,
      function( object_1, object_2 )
        local nr_source, nr_range, basis_elements;
        
        nr_source := VertexIndex( UnderlyingVertex( object_1 ) );
        
        nr_range := VertexIndex( UnderlyingVertex( object_2 ) );
        
        basis_elements := data[nr_source][nr_range];
        
        return object_constructor( Size( basis_elements ) );
        
    end );
    
    ##
    AddHomomorphismStructureOnMorphismsWithGivenObjects( algebroid,
      function( source, alpha, beta, range )
        local elem_alpha, elem_beta, a, b, ap, bp, basis_elements_source, basis_elements_range, size_source, size_range, images, path;
        
        elem_alpha := UnderlyingQuiverAlgebraElement( alpha );
        
        elem_beta := UnderlyingQuiverAlgebraElement( beta );
        
        a := VertexIndex( UnderlyingVertex( Range( alpha ) ) );
        
        b := VertexIndex( UnderlyingVertex( Source( beta ) ) );
        
        ap := VertexIndex( UnderlyingVertex( Source( alpha ) ) );
        
        bp := VertexIndex( UnderlyingVertex( Range( beta ) ) );
        
        basis_elements_source := data[a][b];
        
        basis_elements_range := data[ap][bp];
        
        size_source := Size( basis_elements_source );
        
        size_range := Size( basis_elements_range );
        
        if size_source = 0 or size_range = 0 then
            
            return morphism_constructor( HomalgZeroMatrix( size_source, size_range, ring ) );
            
        fi;
        
        images := [ ];
        
        if IsQuotientOfPathAlgebraElement( elem_alpha ) then
            
            for path in basis_elements_source do
                
                Add( images,
                  CoefficientsOfPaths( basis_elements_range, Representative( elem_alpha * PathAsAlgebraElement( quiver_algebra, path ) * elem_beta ) )
                );
                
            od;
            
        else
        
            for path in basis_elements_source do
                
                Add( images,
                  CoefficientsOfPaths( basis_elements_range, ( elem_alpha * PathAsAlgebraElement( quiver_algebra, path ) * elem_beta ) )
                );
                
            od;
            
        fi;
        
        return morphism_constructor( HomalgMatrix( images, size_source, size_range, ring ) );
        
    end );
    
    ##
    AddDistinguishedObjectOfHomomorphismStructure( algebroid,
      function( )
        
        return distinguished_object();
        
    end );
    
    ##
    AddInterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( algebroid,
      function( alpha )
        local a, b, basis_elements, size_basis, element;
        
        a := VertexIndex( UnderlyingVertex( Source( alpha ) ) );
        
        b := VertexIndex( UnderlyingVertex( Range( alpha ) ) );
        
        basis_elements := data[a][b];
        
        size_basis := Size( basis_elements );
        
        if size_basis = 0 then
            
            return morphism_constructor( HomalgZeroMatrix( 1, 0, ring ) );
            
        fi;
        
        element := UnderlyingQuiverAlgebraElement( alpha );
        
        if IsQuotientOfPathAlgebraElement( element ) then
            
            return morphism_constructor(
                    HomalgMatrix( CoefficientsOfPaths( basis_elements, Representative( element ) ), 1, size_basis, ring )
                  );
            
        else
            
            return morphism_constructor(
                    HomalgMatrix( CoefficientsOfPaths( basis_elements, element ), 1, size_basis, ring )
                  );
            
        fi;
        
    end );
    
    ##
    AddInterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( algebroid,
      function( a, b, morphism )
        local coefficients, basis, element;
        
        coefficients := EntriesOfHomalgMatrix( UnderlyingMatrix( morphism ) );
        
        basis := data[VertexIndex( UnderlyingVertex( a ) )][VertexIndex( UnderlyingVertex( b ) )];
        
        element := QuiverAlgebraElement( quiver_algebra, coefficients, basis );
        
        return MorphismInAlgebroid( a, element, b );
        
    end );
    
end );

##
InstallGlobalFunction( ADD_FUNCTIONS_FOR_RANDOM_METHODS_OF_ALGEBROID,
  function( A, over_Z )
    
    if over_Z then
      
      # to do
      return;
      
    else
      
      AddRandomObjectByInteger( A,
        { A, n } -> Random( SetOfObjects( A ) )
      );
      
      AddRandomMorphismWithFixedSourceByInteger( A,
        function( o, n )
          local objects, p, b; 
          
          objects := Shuffle( ShallowCopy( SetOfObjects( A ) ) );
          
          p := PositionProperty( objects, obj -> not IsZero( HomStructure( o, obj ) ) );
          
          if p = fail then
              return Random( [ 0 .. AbsInt( n ) ] ) * One( UnderlyingAlgebra( A ) ) * IdentityMorphism( o );
          fi;
          
          b := BasisOfExternalHom( o, objects[ p ] );
          
          return Sum( List( [ 0 .. AbsInt( n ) ], i -> Random( b ) ) );
          
      end );
      
      AddRandomMorphismWithFixedRangeByInteger( A,
        function( o, n )
          local objects, p, b;
          
          objects := Shuffle( ShallowCopy( SetOfObjects( A ) ) );
          
          p := PositionProperty( objects, obj -> not IsZero( HomStructure( obj, o ) ) );
          
          if p = fail then
              return Random( [ 0 .. AbsInt( n ) ] ) * One( UnderlyingAlgebra( A ) ) * IdentityMorphism( o );
          fi;
          
          b := BasisOfExternalHom( objects[ p ], o );
          
          return Sum( List( [ 0 .. AbsInt( n ) ], i -> Random( b ) ) );
          
      end );
      
      AddRandomMorphismWithFixedSourceAndRangeByInteger( A,
        function( s, r, n )
          local b;
          
          b := BasisOfExternalHom( s, r );
          
          if IsEmpty( b ) then
              return ZeroMorphism( s, r );
          fi;
          
          return Sum( List( [ 0 .. AbsInt( n ) ], i -> Random( b ) ) );
          
      end );
      
    fi;
    
end );

InstallMethod( CategoryOfAlgebroidsObject,
                        [ IsAlgebroid ],
               
  function( A )
    local category, category_of_algebroids_object;

    category := CategoryOfAlgebroids( CommutativeRingOfLinearCategory( A ), Parity( A ) );
    
    category_of_algebroids_object := rec( );
    
    ObjectifyObjectForCAPWithAttributes( category_of_algebroids_object, 
                                         category,
                                         AsCapCategory, A
    );

    return category_of_algebroids_object;
    
end );

##
InstallMethod( CategoryOfAlgebroidsMorphism,
               [ IsCategoryOfAlgebroidsObject, IsAlgebroidMorphism, IsCategoryOfAlgebroidsObject ],
               
  function( s , morphism, r )
    local category, source, range, category_of_algebroids_morphism;
    

    Assert( 0, IsIdenticalObj( CapCategory( s ), CapCategory( r ) ) );
    Assert( 0, IsIdenticalObj( CapCategory( r ), CapCategory( CategoryOfAlgebroidsObject( AsCapCategory( Range( morphism ) ) ) ) ) );
    Assert( 0, IsIdenticalObj( CapCategory( s ), CapCategory( CategoryOfAlgebroidsObject( AsCapCategory( Source( morphism ) ) ) ) ) );

    category := CapCategory(s);

    category_of_algebroids_morphism := rec( );
    
    ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes( category_of_algebroids_morphism, category,
                                           s,
                                           r,
                                           AsCapFunctor, morphism
    );

    return category_of_algebroids_morphism;
    
end );

InstallMethod( CategoryOfAlgebroidsMorphism,
               [ IsAlgebroidMorphism ],
               
  function( morphism )
    local category, source, range;
    
    return CategoryOfAlgebroidsMorphism( CategoryOfAlgebroidsObject(AsCapCategory(Source(morphism))),
                                         morphism,
                                         CategoryOfAlgebroidsObject(AsCapCategory(Range(morphism)))
                                         );
    
end );

##
InstallMethod( Algebroid,
        "for a QPA quiver algebra",
        [ IsQuiverAlgebra ],
    function( A )
        return Algebroid( A, false );
end );

##
InstallMethod( DescentToZDefinedByBasisPaths,
        "for an algebroid",
        [ IsAlgebroid ],
    function( A )
        return Algebroid( UnderlyingQuiverAlgebra( A ), true );
end );

##
InstallMethod( Algebroid,
        "for a QPA quiver algebra and a boolean",
        [ IsQuiverAlgebra, IsBool ],
        
  function( Rq, over_Z )
    local domain, paths, p, q, parity, quiver, A;
    
    domain := LeftActingDomain( Rq );
    
    if over_Z then
        
        if IsIdenticalObj( domain, Rationals )
           or
           ( HasIsRationalsForHomalg( domain ) and IsRationalsForHomalg( domain )
             and not IsHomalgExternalRingRep( domain ) )
        then
            
            ## Test if the multiplication table which is induced by the basis of the quiver algebra
            ## (computed by the Groebner basis) only has integral coefficients.
            paths := BasisPaths( CanonicalBasis( Rq ) );
            
            for p in paths do
                
                for q in paths do
                    
                    if not ForAll( Coefficients( PathAsAlgebraElement( Rq, p ) * PathAsAlgebraElement( Rq, q ) ), IsInt ) then
                        
                        Error( "the basis of the given quiver algebra does give rise to a well-defined algebroid over Z\n");
                        
                    fi;
                    
                od;
                
            od;
            
        else
            
            Error( "the left acting domain of the given quiver algebra is not supported for constructing an algebroid of the integers\n");
            
        fi;
        
    fi;
    
    if IsRightQuiverAlgebra( Rq ) then
        parity := "right";
    else
        parity := "left";
    fi;
    
    quiver := QuiverOfAlgebra( Rq );
    
    if Length( Vertices( quiver ) ) > 1 then
        A := "Algebroid";
    else
        A := "Algebra";
    fi;
    
    if over_Z then
        
        A := Concatenation( A, " over Z");
        
    fi;
    
    A := Concatenation( A, " generated by the ", parity, " quiver ", String( quiver ) );
    
    A := CreateCapCategory( A );
    
    DeactivateCachingOfCategory( A );
    CapCategorySwitchLogicOff( A );
    DisableSanityChecks( A );
    
    AddObjectRepresentation( A, IsCapCategoryObjectInAlgebroidRep );
    AddMorphismRepresentation( A, IsCapCategoryMorphismInAlgebroidRep );
    
    SetIsAbCategory( A, true );
    SetIsLinearCategoryOverCommutativeRing( A, true );
    
    SetIsFinitelyPresentedCategory( A, true );
    SetUnderlyingQuiver( A, quiver );
    SetUnderlyingAlgebra( A, domain );
    SetParity( A, parity );
    
    if over_Z then
        SetCommutativeRingOfLinearCategory( A, HomalgRingOfIntegers() );
    else
        SetCommutativeRingOfLinearCategory( A, LeftActingDomain( Rq ) );
    fi;
    
    SetUnderlyingQuiverAlgebra( A, Rq );
    SetFilterObj( A, IsAlgebroid );
    if Length( Vertices( quiver ) ) = 1 then
        SetFilterObj( A, IsAlgebraAsCategory );
    fi;
    
    A!.Vertices := rec( );
    A!.Arrows := rec( );
    
    return ADD_FUNCTIONS_FOR_ALGEBROID( A, over_Z );
    
end );

##
InstallMethod( Algebroid,
        "for a QPA path algebra and a list",
        [ IsPathAlgebra, IsList ],
        
  function( Rq, L )
    local path;
    
    for path in L do
        if not IsUniform( path ) then
            Error( "only uniform relations are admissible, while the path ", path, " is not uniform\n" );
        fi;
    od;
    
    L := Filtered( L, r -> not IsZero( r ) );
    
    return Algebroid( Rq / Ideal( Rq, L ) );
    
end );

##
InstallMethod( Algebroid,
        "for a homalg ring and a QPA quiver",
        [ IsHomalgRing, IsQuiver ],
        
  function( R, quiver )
    
    return Algebroid( PathAlgebra( R, quiver ) );
    
end );


##
InstallMethod( Multiplication,
        "for a commutative algebra as cateogry",
        [ IsAlgebraAsCategory and IsCommutative ],
  function (A)
    local unique_object_in_A, unique_object_in_A_string, morphisms_in_A, A2, unique_object_in_A2, unique_object_in_A2_string, mult_functor_images_of_objects, mult_functor_images_of_morphisms, a, b, axg, axg_string, fxb, fxb_string, mult_functor, g, f;

    unique_object_in_A := SetOfObjects( A )[1];
    unique_object_in_A_string := String( UnderlyingVertex( unique_object_in_A ) );
    morphisms_in_A := SetOfGeneratingMorphisms(A);

    A2 := A*A;
    
    unique_object_in_A2 := SetOfObjects( A2 )[1];
    unique_object_in_A2_string := String( UnderlyingVertex( unique_object_in_A2 ) );
    
    mult_functor_images_of_objects := rec( );
    mult_functor_images_of_objects.(unique_object_in_A2_string) := unique_object_in_A;

    mult_functor_images_of_morphisms := rec(); # FIXME

    a := unique_object_in_A;
    b := unique_object_in_A;

    for g in morphisms_in_A do

        axg := ElementaryTensor( a, g, A2 );
        axg_string := String( LeadingPath( Representative( UnderlyingQuiverAlgebraElement( axg ) ) ) );

        mult_functor_images_of_morphisms.(axg_string) := g;

    od;

    for f in morphisms_in_A do

        fxb := ElementaryTensor( f, b, A2 );
        fxb_string := String( LeadingPath( Representative( UnderlyingQuiverAlgebraElement( fxb ) ) ) );

        mult_functor_images_of_morphisms.(fxb_string) := f;

    od;
    
    mult_functor := CapFunctor( A2, mult_functor_images_of_objects, mult_functor_images_of_morphisms );
    
    return mult_functor;

end );

##
InstallMethod( Unit,
        "for algebra as category",
        [ IsAlgebraAsCategory ],
  function( A )
    local unique_object_in_A, unique_object_in_A_string, unique_object_in_A0, unique_object_in_A0_string, unit_functor_images_of_objects, unit_functor_images_of_morphisms, A0;
    
    unique_object_in_A := SetOfObjects( A )[1];
    unique_object_in_A_string := String( UnderlyingVertex( unique_object_in_A ) );
    
    A0 := A^0;
    
    unique_object_in_A0 := SetOfObjects( A0 )[1];
    unique_object_in_A0_string := String( UnderlyingVertex( unique_object_in_A0 ) );
    
    unit_functor_images_of_objects := rec( );
    unit_functor_images_of_objects.(unique_object_in_A0_string) := unique_object_in_A;
    unit_functor_images_of_morphisms := rec( );
    
    return CapFunctor(A0, unit_functor_images_of_objects, unit_functor_images_of_morphisms );
end );

InstallMethod( LeftUnitorAsFunctor,
        "for algebroid as category",
        [ IsAlgebroid ],
  function( A )
    local objects_in_A, k, kxA, unique_object_in_k, objects_in_kxA, unitor_functor_images_of_objects, unitor_functor_images_of_morphisms, s, o, m;
    
    objects_in_A := SetOfObjects( A );
    
    k := A^0;
    
    kxA := TensorProductOnObjects(k, A);

    unique_object_in_k := SetOfObjects( k )[1];
    
    objects_in_kxA := SetOfObjects( kxA )[1];

    unitor_functor_images_of_objects := rec( );
    for o in objects_in_A do
        unitor_functor_images_of_objects.(String(UnderlyingVertex(ElementaryTensor( unique_object_in_k, o, kxA ) ) ) ) := o;
    od;
    
    unitor_functor_images_of_morphisms := rec();
    for m in SetOfGeneratingMorphisms( A ) do
        s := String( Paths( UnderlyingQuiverAlgebraElement( ElementaryTensor( unique_object_in_k, m, kxA) ) )[1] );
        unitor_functor_images_of_morphisms.(s) := m;
    od;

    return CapFunctor(kxA, unitor_functor_images_of_objects, unitor_functor_images_of_morphisms);
end );

InstallMethod( RightUnitorAsFunctor,
        "for algebroid as category",
        [ IsAlgebroid ],
  function( A )
    local objects_in_A, k, Axk, unique_object_in_k, objects_in_Axk, unitor_functor_images_of_objects, unitor_functor_images_of_morphisms, s, o, m;
    
    objects_in_A := SetOfObjects( A );
    
    k := A^0;
    
    Axk := TensorProductOnObjects(A, k);

    unique_object_in_k := SetOfObjects( k )[1];
    
    objects_in_Axk := SetOfObjects( Axk )[1];
    
    unitor_functor_images_of_objects := rec( );
    for o in objects_in_A do
        unitor_functor_images_of_objects.(String(UnderlyingVertex(ElementaryTensor( o, unique_object_in_k, Axk ) ) ) ) := o;
    od;
    
    unitor_functor_images_of_morphisms := rec();
    for m in SetOfGeneratingMorphisms( A ) do
        s := String(Paths(UnderlyingQuiverAlgebraElement( ElementaryTensor(m, unique_object_in_k, Axk) ))[1]);
        unitor_functor_images_of_morphisms.(s) := m;
    od;

    return CapFunctor(Axk, unitor_functor_images_of_objects, unitor_functor_images_of_morphisms);
end );

InstallMethod( LeftUnitorInverseAsFunctor,
        "for algebroid as category",
        [ IsAlgebroid ],
  function( A )
    local objects_in_A, k, kxA, unique_object_in_k, objects_in_kxA, unitor_inverse_functor_images_of_objects, unitor_inverse_functor_images_of_morphisms, s, o, m;
    
    objects_in_A := SetOfObjects( A );
    
    k := A^0;
    
    kxA := TensorProductOnObjects(k, A);

    unique_object_in_k := SetOfObjects( k )[1];
    
    objects_in_kxA := SetOfObjects( kxA )[1];

    unitor_inverse_functor_images_of_objects := rec( );
    for o in objects_in_A do
        unitor_inverse_functor_images_of_objects.(String(UnderlyingVertex(o))) := ElementaryTensor( unique_object_in_k, o, kxA );
    od;
    
    unitor_inverse_functor_images_of_morphisms := rec();
    for m in SetOfGeneratingMorphisms( A ) do
        s := String( Paths(UnderlyingQuiverAlgebraElement(m))[1] );
        unitor_inverse_functor_images_of_morphisms.(s) := ElementaryTensor(unique_object_in_k, m, kxA);
    od;

    return CapFunctor(A, unitor_inverse_functor_images_of_objects, unitor_inverse_functor_images_of_morphisms);
end );

InstallMethod( RightUnitorInverseAsFunctor,
        "for algebroid as category",
        [ IsAlgebroid ],
  function( A )
    local objects_in_A, k, Axk, unique_object_in_k, unitor_inverse_functor_images_of_objects, unitor_inverse_functor_images_of_morphisms, s, o, m;
    
    objects_in_A := SetOfObjects( A );
    
    k := A^0;
    
    Axk := TensorProductOnObjects(A, k);

    unique_object_in_k := SetOfObjects( k )[1];

    unitor_inverse_functor_images_of_objects := rec( );
    for o in objects_in_A do
        unitor_inverse_functor_images_of_objects.(String(UnderlyingVertex(o))) := ElementaryTensor( o, unique_object_in_k, Axk );
    od;
    
    unitor_inverse_functor_images_of_morphisms := rec();
    
    for m in SetOfGeneratingMorphisms( A ) do
        s := String( Paths(UnderlyingQuiverAlgebraElement(m))[1] );
        unitor_inverse_functor_images_of_morphisms.(s) := ElementaryTensor(m, unique_object_in_k, Axk);
    od;

    return CapFunctor(A, unitor_inverse_functor_images_of_objects, unitor_inverse_functor_images_of_morphisms);
end );


InstallMethod( AssociatorLeftToRightWithGivenTensorProductsAsFunctor,
        "for algebroids as categories",
        [ IsAlgebroid, IsAlgebroid, IsAlgebroid, IsAlgebroid, IsAlgebroid ],
  function( AxB_C, A, B, C, A_BxC )
    local algebra_of_AxB_C, algebra_of_A_BxC, iso_to_flat, iso_from_flat, functor_images_of_morphisms, functor_images_of_objects, m_flat, m_right, m_string, m_right_string, o_string, o_flat, o_right, o_right_string, m, o;
    algebra_of_AxB_C := UnderlyingQuiverAlgebra(AxB_C);
    algebra_of_A_BxC := UnderlyingQuiverAlgebra(A_BxC);
    iso_to_flat := IsomorphismToFlatTensorProduct(algebra_of_AxB_C);
    iso_from_flat := IsomorphismFromFlatTensorProduct(algebra_of_A_BxC);
  
    functor_images_of_morphisms := rec();
    functor_images_of_objects := rec();

    for m in SetOfGeneratingMorphisms( AxB_C ) do
        m_flat := ImageElm( iso_to_flat, UnderlyingQuiverAlgebraElement(m) );
        m_right := ImageElm( iso_from_flat, m_flat );
        m_string := String(Paths(UnderlyingQuiverAlgebraElement(m))[1]);
        m_right_string := String(Paths(m_right)[1]);
        functor_images_of_morphisms.(m_string) := A_BxC.(m_right_string);
    od;
    for o in SetOfObjects( AxB_C ) do
        o_string := String( UnderlyingVertex( o ) );
        o_flat := ImageElm( iso_to_flat, PathAsAlgebraElement( algebra_of_AxB_C, UnderlyingVertex(o) ) );
        o_right := ImageElm( iso_from_flat, o_flat );
        o_right_string := String(Paths(o_right)[1]);
        functor_images_of_objects.(o_string) := A_BxC.(o_right_string); 
    od;

    return CapFunctor( AxB_C, functor_images_of_objects, functor_images_of_morphisms );
end );

InstallMethod( AssociatorRightToLeftWithGivenTensorProductsAsFunctor,
        "for algebroids as categories",
        [ IsAlgebroid, IsAlgebroid, IsAlgebroid, IsAlgebroid, IsAlgebroid ],
  function( A_BxC, A, B, C, AxB_C )
    local algebra_of_A_BxC, algebra_of_AxB_C, iso_to_flat, iso_from_flat, functor_images_of_morphisms, functor_images_of_objects, m_flat, m_right, s, o_string, o_flat, o_left, o_left_string, m, o;
    algebra_of_A_BxC := UnderlyingQuiverAlgebra(A_BxC);
    algebra_of_AxB_C := UnderlyingQuiverAlgebra(AxB_C);
    iso_to_flat := IsomorphismToFlatTensorProduct(algebra_of_A_BxC);
    iso_from_flat := IsomorphismFromFlatTensorProduct(algebra_of_AxB_C);
  
    functor_images_of_morphisms := rec();
    functor_images_of_objects := rec();

    for m in SetOfGeneratingMorphisms( A_BxC ) do
        m_flat := ImageElm( iso_to_flat, UnderlyingQuiverAlgebraElement(m) );
        m_right := ImageElm( iso_from_flat, m_flat );
        s := String(Paths(m_right)[1]);
        functor_images_of_morphisms.(s) := AxB_C.(s);
    od;
    for o in SetOfObjects( A_BxC ) do
        o_string := String( UnderlyingVertex( o ) );
        o_flat := ImageElm( iso_to_flat, PathAsAlgebraElement( algebra_of_A_BxC, UnderlyingVertex(o) ) );
        o_left := ImageElm( iso_from_flat, o_flat );
        o_left_string := String(Paths(o_left)[1]);
        functor_images_of_objects.(o_string) := AxB_C.(o_left_string);
    od;

    return CapFunctor( A_BxC, functor_images_of_objects, functor_images_of_morphisms );
end );

##
InstallMethod( \.,
        "for an algebroid and a positive integer",
        [ IsAlgebroid, IsPosInt ],
        
  function( B, string_as_int )
    local name, q, a, b;
    
    name := NameRNam( string_as_int );
    
    q := UnderlyingQuiver( B );
    
    a := q.(name);
    
    b := rec( );
    
    if IsQuiverVertex( a ) then
        if IsBound( B!.Vertices.(name) ) then
            return B!.Vertices.(name);
        fi;
        ObjectifyObjectForCAPWithAttributes(
            b, B,
            UnderlyingVertex, a
        );
        B!.Vertices.(name) := b;
    elif IsArrow( a ) or IsCompositePath( a ) then
        if IsBound( B!.Arrows.(name) ) then
            return B!.Arrows.(name);
        fi;
        b := MorphismInAlgebroid(
                     B.(String( Source( a ) ) ),
                     PathAsAlgebraElement( UnderlyingQuiverAlgebra( B ), a ),
                     B.(String( Target( a ) ) ) );
        B!.Arrows.(name) := b;
    else
        Error( "the given component ", name, " is neither a vertex nor an arrow of the quiver q = ", q, "\n" );
    fi;
    
    return b;
    
end );

InstallMethod( ObjectInAlgebroid,
         "for an algebroid and a vertex of a quiver",
        [ IsAlgebroid, IsQuiverVertex ],
  function( A, v )
    local o;
    o := rec();
    ObjectifyObjectForCAPWithAttributes(
        o, A,
        UnderlyingVertex, v
    );
    A!.Vertices.(String(v)) := o;
    return o;
end );

##
InstallMethod( \/,
        [ IsQuiverVertex, IsAlgebroid ],
        
  { v, A } -> ObjectInAlgebroid( A, v )
);

##
InstallMethod( MorphismInAlgebroid,
        "for two objects in an algebroid and an element of the quiver algebra",
        [ IsCapCategoryObjectInAlgebroidRep, IsQuiverAlgebraElement, IsCapCategoryObjectInAlgebroidRep ],
        
  function( S, path, T )
    local l, mor, A;
    
    if not IsZero( path ) then
        
        if not IsUniform( path ) then
            Error( "the path ", path, " is neither zero nor uniform\n" );
        fi;
        
        ## TODO: we are avoiding for the moment the sanity test for
        ## elements of path algebras with relations, this should be
        ## reintroduced in the future
        if IsPathAlgebraElement( path ) then
            l := LeadingPath( path );
        
            if not ( Source( l ) = UnderlyingVertex( S ) ) and not ( Target( l ) = UnderlyingVertex( T ) ) then
                Error( "the path ", path, " is not zero, it does not match the given source S and it does not match the given target T\n" );
            elif not ( Source( l ) = UnderlyingVertex( S ) ) then
                Error( "the path ", path, " is not zero and it does not match the given source S\n" );
            elif not ( Target( l ) = UnderlyingVertex( T ) ) then
                Error( "the path ", path, " is not zero and it does not match the given target T\n" );
            fi;
        fi;
        
    fi;
    
    mor := rec( );
    
    if not IsIdenticalObj( CapCategory(S), CapCategory(T) ) then
        Error( "source and target do not belong to the same category");
    fi;

    A := CapCategory( S );
    
    ObjectifyMorphismWithSourceAndRangeForCAPWithAttributes(
            mor, A,
            S,
            T,
            UnderlyingQuiverAlgebraElement, path
            );
    
    return mor;
    
end );

##
InstallMethod( MorphismInAlgebroid,
        "an element of a path algebra",
        [ IsPathAlgebraElement ],
        
  function( path )
    local A, l, S, T;
    
    if IsZero( path ) then
        Error( "source and target of the zero path is ambiguous\n" );
    elif not IsUniform( path ) then
        Error( "the path ", path, " is not uniform\n" );
    fi;
    
    A := Algebroid( AlgebraOfElement( path ) );
    
    l := LeadingPath( path );
    
    S := String( Source( l ) );
    T := String( Target( l ) );
    
    return MorphismInAlgebroid( A.(S), path, A.(T) );
    
end );

##
InstallMethod( \/,
        [ IsPathAlgebraElement, IsAlgebroid ],
        
  function( path, A )
    
    if not IsIdenticalObj( Algebroid( AlgebraOfElement( path ) ), A ) then
        Error( "Wrong input!\n" );
    fi;
    
    return MorphismInAlgebroid( path );
    
end );

##
InstallMethod( MorphismInAlgebroid,
        "an element of a quotient of a path algebra",
        [ IsQuotientOfPathAlgebraElement],
        
  function( path )
    local A, l, S, T;
    
    if IsZero( path ) then
        Error( "source and target of the zero path is ambiguous\n" );
    elif not IsUniform( path ) then
        Error( "the path ", path, " is not uniform\n" );
    fi;
    
    A := Algebroid( AlgebraOfElement( path ) );
    l := LeadingPath( Representative( path ) );
    
    S := String( Source( l ) );
    T := String( Target( l ) );
    
    return MorphismInAlgebroid( A.(S), path, A.(T) );
    
end );

##
InstallMethod( \/,
        [ IsQuotientOfPathAlgebraElement, IsAlgebroid ],
        
  function( path, A )
    
    if not IsIdenticalObj( Algebroid( AlgebraOfElement( path ) ), A ) then
        Error( "Wrong input!\n" );
    fi;
    
    return MorphismInAlgebroid( path );
    
end );

##
InstallMethod( POW,
        "for an algebroid and an integer",
        [ IsAlgebroid and HasUnderlyingQuiverAlgebra, IsInt ],
        
  function( A, n )
    local Rq, R, trivial_quiver;
    
    if n < 0 then
        Error( "the only admissible values for n are non-negative integers\n" );
    elif n = 1 then
        return A;
    elif not IsBound( A!.powers ) then
        A!.powers := rec( );
    fi;
    
    Rq := UnderlyingQuiverAlgebra( A );
    
    R := LeftActingDomain( Rq );
    
    if n = 0 then
        
        if not IsBound( A!.powers.0 ) then
            
            if IsRightQuiverAlgebra( Rq ) then
                trivial_quiver := RightQuiver( "*(1)[]" );
            else
                trivial_quiver := LeftQuiver( "*(1)[]" );
            fi;
            
            A!.powers.0 := Algebroid( PathAlgebra( R, trivial_quiver ) );
            
        fi;
        
        return A!.powers.0;
        
    fi;
    
    A!.powers.1 := A;
    
    if not IsBound( A!.powers.(n) ) then
        if not IsBound( A!.powers.(n-1) ) then
            A!.powers.(n-1) := A^(n-1);
        fi;
        
        A!.powers.(n) := A!.powers.(n-1) * A;
        
        A!.powers.(n)!.PowerOf := A;
        
    fi;
    
    return A!.powers.(n);
    
end );

##
InstallMethod( TrivialAlgebroid,
        "for a homalg ring",
        [ IsHomalgRing, IsString ],
  function( R, parity )
    local trivial_quiver;
   
    if parity = "right" then
        trivial_quiver := RightQuiver( "*(1)[]" );
    elif parity = "left" then
        trivial_quiver := LeftQuiver( "*(1)[]" );
    else
        Error( "parity must be either \"left\" or \"right\"" );
    fi;
    
    return Algebroid( PathAlgebra( R, trivial_quiver ) );
end );

##
InstallMethod(ElementaryTensor,
        "for objects in algebroids",
        [ IsCapCategoryObjectInAlgebroid, IsCapCategoryObjectInAlgebroid, IsAlgebroid ],
  function( a, b, T )
      
    local product_string, a_string, b_string, product_vertex;
  
    product_vertex := PathInProductQuiver( QuiverOfAlgebra( UnderlyingQuiverAlgebra( T ) ), [ UnderlyingVertex( a ), UnderlyingVertex( b ) ] );
    product_string := String(product_vertex);
  
    return T.(product_string);
end);

##
InstallMethod(ElementaryTensor,
        "for object and morphism in algebroids",
        [ IsCapCategoryObjectInAlgebroid, IsCapCategoryMorphismInAlgebroid, IsAlgebroid ],
  function( object, morphism, T )
    local product_string, coeffs, paths, object_string, sum, i, source, range, morphism_as_quiver_algebra_element, object_underlying_vertex, mors, algebroid_of_morphism, o, product_of_arrows_as_morphism, b, arrows_of_path;

    source := ElementaryTensor( object, Source(morphism), T );
    range := ElementaryTensor( object, Range(morphism), T );

    morphism_as_quiver_algebra_element := UnderlyingQuiverAlgebraElement( morphism );
    
    if IsQuotientOfPathAlgebraElement( morphism_as_quiver_algebra_element ) then
    
        morphism_as_quiver_algebra_element := Representative( morphism_as_quiver_algebra_element );
    
    fi;
    
    if IsZero(morphism_as_quiver_algebra_element) then
      
        return ZeroMorphism( source, range );

    else

        paths := Paths( morphism_as_quiver_algebra_element );
        coeffs := Coefficients( morphism_as_quiver_algebra_element );

        object_underlying_vertex := UnderlyingVertex( object );
        object_string := String( object_underlying_vertex );
       
        sum := ZeroMorphism( source, range );
        
        for i in [1..Length(paths)] do
          
            arrows_of_path := ArrowList( paths[i] ) ;
            
            mors := List( List( arrows_of_path, b -> PathInProductQuiver( QuiverOfAlgebra( UnderlyingQuiverAlgebra( T ) ), [ object_underlying_vertex, b ] ) ), b -> MorphismInAlgebroid( ObjectInAlgebroid( T, Source( b ) ), QuiverAlgebraElement( UnderlyingQuiverAlgebra( T ), [ 1 ], [ b ] ), ObjectInAlgebroid( T, Target( b ) ) ) );
            
            if Length( mors ) > 0 then
              
                product_of_arrows_as_morphism := PreCompose( mors );
              
            else
              
                Assert( 3, IsQuiverVertex( paths[i] ) );
                
                algebroid_of_morphism := CapCategory( morphism );
                
                o := ObjectInAlgebroid( algebroid_of_morphism, paths[i] );
                
                Assert( 3, o = Source( morphism ) and o = Range( morphism ) );
                
                product_of_arrows_as_morphism := IdentityMorphism( ElementaryTensor( object, o, T ) );
              
            fi;
            
            sum := sum + coeffs[i] * product_of_arrows_as_morphism;
          
        od;
        
        return sum;
      
    fi;
end );

##
InstallMethod(ElementaryTensor,
        "for morphism and object in algebroids",
        [ IsCapCategoryMorphismInAlgebroid, IsCapCategoryObjectInAlgebroid, IsAlgebroid ],
  function( morphism, object, T )
    local product_string, morphism_as_quiver_algebra_element, coeffs, paths, object_string, sum, i, source, range, object_underlying_vertex, mors, o, algebroid_of_morphism, product_of_arrows_as_morphism, arrows_of_path;

    source := ElementaryTensor( Source( morphism ), object, T );
    range := ElementaryTensor( Range( morphism ), object, T );
    
    morphism_as_quiver_algebra_element := UnderlyingQuiverAlgebraElement( morphism );

    if IsQuotientOfPathAlgebraElement( morphism_as_quiver_algebra_element ) then

        morphism_as_quiver_algebra_element := Representative( morphism_as_quiver_algebra_element );

    fi;

    if IsZero( morphism_as_quiver_algebra_element ) then

        return ZeroMorphism( source, range );

    else

        paths := Paths( morphism_as_quiver_algebra_element );
        coeffs := Coefficients( morphism_as_quiver_algebra_element );

        object_underlying_vertex := UnderlyingVertex( object );
        object_string := String( object_underlying_vertex );
       
        sum := ZeroMorphism( source, range );

        for i in [1..Length( paths )] do

            arrows_of_path := ArrowList( paths[ i ] );
                    
            mors := List( List( arrows_of_path, a -> PathInProductQuiver( QuiverOfAlgebra( UnderlyingQuiverAlgebra( T ) ), [ a, object_underlying_vertex ] ) ), a -> MorphismInAlgebroid( ObjectInAlgebroid( T, Source(a) ), QuiverAlgebraElement(UnderlyingQuiverAlgebra(T), [1], [a]), ObjectInAlgebroid(T, Target(a)) ) );

            if Length(mors) > 0 then

                product_of_arrows_as_morphism := PreCompose( mors );

            else

                Assert( 3, IsQuiverVertex( paths[i] ) );

                algebroid_of_morphism := CapCategory( morphism );

                o := ObjectInAlgebroid( algebroid_of_morphism, paths[i] );

                Assert( 3, o = Source( morphism ) and o = Range( morphism ) );

                product_of_arrows_as_morphism := IdentityMorphism( ElementaryTensor( o, object, T ) );
       
            fi;

            sum := sum + coeffs[i] * product_of_arrows_as_morphism;
            
        od;
        
        return sum;

    fi;
end );

##
InstallMethod(TensorProductOnObjects,
        "for algebroids",
        [ IsAlgebroid, IsAlgebroid ],
  function( X, Y )

    return X * Y;

end );

##
InstallMethod(TensorProductOnMorphisms,
        "for morphisms between algebroids",
        [ IsAlgebroidMorphism, IsAlgebroidMorphism ],
  function( F, G )
    local SF, SG, TF, TG, SF_objects, SG_objects, SFxSG, SFxSG_quiver_algebra, images_of_SF_objects_under_F, images_of_SG_objects_under_G, TFxTG, record_with_images_of_objects, a, b, axb, Gb, Fa, SF_mor, SG_mor, SF_mor_underlying_quiver_algebra_elements, SG_mor_underlying_quiver_algebra_elements, SF_mor_underlying_paths, SG_mor_underlying_paths, record_with_images_of_morphisms, g, axg, f, TF_objects, TG_objects, l, fxb, Ts, product_of_sources, product_of_targets, objects_of_product_of_targets, objects_of_product_of_sources, s, t, p, rp, lp, products_of_quiver_algebra_elements_of_generating_morphisms_of_sources, x;

    SF := AsCapCategory( Source( F ) );
    SG := AsCapCategory( Source( G ) );

    TF := AsCapCategory( Range( F ) );
    TG := AsCapCategory( Range( G ) );

    SF_objects := SetOfObjects( SF );
    SG_objects := SetOfObjects( SG );

    images_of_SF_objects_under_F := List( SF_objects, obj -> ApplyFunctor( F, obj ) );
    images_of_SG_objects_under_G := List( SG_objects, obj -> ApplyFunctor( G, obj ) );
    
    SFxSG := SF * SG;
    TFxTG := TF * TG;
    
    SFxSG_quiver_algebra := UnderlyingQuiverAlgebra( SFxSG );
    
    record_with_images_of_objects := rec();
    for a in SF_objects do
      for b in SG_objects do

        axb := ElementaryTensor( a, b, SFxSG );

        Fa := ApplyFunctor( F, a );
        Gb := ApplyFunctor( G, b );

        record_with_images_of_objects.( String( UnderlyingVertex( axb ) ) ) := ElementaryTensor( Fa, Gb, TFxTG );

      od;
    od;

    SF_mor := SetOfGeneratingMorphisms( SF );
    SG_mor := SetOfGeneratingMorphisms( SG );

    SF_mor_underlying_quiver_algebra_elements := List( SF_mor, UnderlyingQuiverAlgebraElement );
    SG_mor_underlying_quiver_algebra_elements := List( SG_mor, UnderlyingQuiverAlgebraElement );
    
    record_with_images_of_morphisms := rec();

    for a in SF_objects do
      for g in SG_mor do

        axg := ElementaryTensor( a, g, SFxSG );
        axg := UnderlyingQuiverAlgebraElement( axg );
        
        if not IsPathAlgebraElement( axg ) then
        
          axg := Representative( axg );

        fi;
        
        axg := String( LeadingPath( axg ) );

        record_with_images_of_morphisms.(axg) := ElementaryTensor( ApplyFunctor( F, a ), ApplyFunctor( G, g ), TFxTG );

      od;
    od;

    for f in SF_mor do
      for b in SG_objects do

        fxb := ElementaryTensor( f, b, SFxSG );
        fxb := UnderlyingQuiverAlgebraElement( fxb );

        if not IsPathAlgebraElement( fxb ) then

          fxb := Representative( fxb );

        fi;

        fxb := String( LeadingPath( fxb ) );

        record_with_images_of_morphisms.(fxb) := ElementaryTensor( ApplyFunctor( F, f ), ApplyFunctor( G, b ), TFxTG );

      od;
    od;

    TF_objects := SetOfObjects( TF );
    TG_objects := SetOfObjects( TG );

    l := Length( SF_mor );
    Ts := List( [1..l], x -> SFxSG_quiver_algebra );
    
    product_of_sources := SF*SG;
    product_of_targets := TF*TG;

    objects_of_product_of_sources := SetOfObjects( product_of_sources );
    objects_of_product_of_targets := SetOfObjects( product_of_targets );

    products_of_quiver_algebra_elements_of_generating_morphisms_of_sources := ListX( SF_mor_underlying_quiver_algebra_elements, SG_mor_underlying_quiver_algebra_elements, Ts, ElementaryTensor );

    return CapFunctor( SFxSG, record_with_images_of_objects, record_with_images_of_morphisms );

end );

##
InstallMethod( \*,
        "for two algebroids",
        [ IsAlgebroid and HasUnderlyingQuiverAlgebra, IsAlgebroid and HasUnderlyingQuiverAlgebra ],
        
  function( A, B )
    return Algebroid( TensorProductOfAlgebras( UnderlyingQuiverAlgebra( A ), UnderlyingQuiverAlgebra( B ) ) );
end );

##
InstallMethod( CapFunctor,
        "for an algebroid and two records",
        [ IsAlgebroid, IsRecord, IsRecord ],
        
  function( A, rec_images_of_objects, rec_images_of_morphisms )
    local b, Rq, B, functor, names_morphisms, names_objects;
    
    names_morphisms := NamesOfComponents( rec_images_of_morphisms );
    names_objects := NamesOfComponents( rec_images_of_objects );
    
    if names_objects = [ ] then
        Error( "the record of images of objects is empty\n" );
    fi;

    # Construct the target category B
    if Length(names_morphisms) > 0 then
        for b in names_morphisms do
            if IsQuiverAlgebraElement( rec_images_of_morphisms.(b) ) then
                Rq := AlgebraOfElement( rec_images_of_morphisms.(b) );
                B := Algebroid( Rq );
                break;
            elif IsCapCategoryCell( rec_images_of_morphisms.(b) ) then
                if not IsCapCategoryMorphism( rec_images_of_morphisms.(b) ) then
                    Error( Concatenation( "image of ", String(b), " is not a morphism"));
                fi;

                B := CapCategory( rec_images_of_morphisms.(b) );
                break;
            fi;
        od;
    else
        B := CapCategory( rec_images_of_objects.(names_objects[1]) );
    fi;

    if not IsBound( B ) then
        Error( "unable to extract target category from the records of images\n" );
    fi;
    
    functor := Concatenation( "Functor from finitely presented ", Name( A ), " -> ", Name( B ) );
   
    functor := CapFunctor( functor, A, B );
    
    AddObjectFunction( functor,
            obj -> rec_images_of_objects.(String( UnderlyingVertex( obj ) )) );
    
    AddMorphismFunction( functor,
            function( new_source, mor, new_range )
              if IsBound( functor!.IsContravariant ) and functor!.IsContravariant then
                  return ApplyToQuiverAlgebraElement( rec_images_of_objects, rec_images_of_morphisms, UnderlyingQuiverAlgebraElement( mor ), true);
              else
                  return ApplyToQuiverAlgebraElement( rec_images_of_objects, rec_images_of_morphisms, UnderlyingQuiverAlgebraElement( mor ), false );
              fi;
            end );
    
    SetFilterObj( functor, IsAlgebroidMorphism );
    
    return functor;
    
end );

##
InstallMethod( CapFunctor,
        "for an algebroid and two lists",
        [ IsAlgebroid, IsList, IsList ],
        
  function( A, images_of_objects, images_of_morphisms )
    local  kq, vertices, arrows, rec_images_of_objects, rec_images_of_morphisms, i;
    
    kq := QuiverOfAlgebra( UnderlyingQuiverAlgebra( A ) );
    
    vertices := Vertices( kq );
    arrows := Arrows( kq );
    
    rec_images_of_objects := rec( );
    rec_images_of_morphisms := rec( );
    
    for i in [ 1 .. Length( vertices ) ] do
        rec_images_of_objects.(String( vertices[i] )) := images_of_objects[i];
    od;
    
    for i in [ 1 .. Length( arrows ) ] do
        rec_images_of_morphisms.(String( arrows[i] )) := images_of_morphisms[i];
    od;
    
    return CapFunctor( A, rec_images_of_objects, rec_images_of_morphisms );
    
end );

##
InstallMethod( Opposite,
        "for an algebroid",
        [ IsAlgebroid and HasUnderlyingQuiver ],
        
  function( A )
    local q_op, R, A_op;
    
    q_op := OppositeQuiver( UnderlyingQuiver( A ) );
    
    R := LeftActingDomain( UnderlyingQuiverAlgebra( A ) );
    
    A_op := Algebroid( R, q_op );
    
    SetOpposite( A_op, A );
    
    return A_op;
    
end );

####################################
#
# methods for properties:
#
####################################

##
InstallMethod( IsCommutative,
        "for an Algebroid",
        [ IsAlgebroid ],
     
  function( A )
    local arrows, i, j;
    
    arrows := Arrows( UnderlyingQuiverAlgebra( A ) );
    
    for i in [ 1 .. Length(arrows) ] do
      for j in [ (i+1) .. Length(arrows) ] do
        if not arrows[i]*arrows[j] = arrows[j]*arrows[i] then
          return false;
        fi;
      od;
    od;
    
    return true;
end );

##
InstallMethod( IsCommutative,
        "for a commutative algebra",
        [ IsCategoryOfAlgebroidsObject ],
  function(B)
    return IsCommutative( AsCapCategory( B ) );
end);

##
InstallMethod( Twist,
        "for two algebroids",
        [ IsAlgebroid, IsAlgebroid ],
  function( A, B )
    local A_underlying_quiver_algebra, B_underlying_quiver_algebra, AxB, BxA, A_objects, B_objects, A_morphisms, B_morphisms, a, b, record_with_images_of_objects, record_with_images_of_morphisms, axg, axg_string, fxb, fxb_string, g, f;
    
    A_underlying_quiver_algebra := UnderlyingQuiver( A );
    B_underlying_quiver_algebra := UnderlyingQuiver( B );
    
    AxB := A * B;
    BxA := B * A;
    
    A_objects := SetOfObjects( A );
    B_objects := SetOfObjects( B );
    
    A_morphisms := SetOfGeneratingMorphisms( A );
    B_morphisms := SetOfGeneratingMorphisms( B );
    
    record_with_images_of_objects := rec( );

    for a in A_objects do
      for b in B_objects do
        record_with_images_of_objects.( String( UnderlyingVertex( ElementaryTensor( a, b, AxB ) ) ) ) := ElementaryTensor( b, a, BxA );
      od;
    od;
    
    record_with_images_of_morphisms := rec( );
    
    for a in A_objects do
        for g in B_morphisms do
            axg := ElementaryTensor( a, g, AxB );
            axg_string := String( LeadingPath( Representative( UnderlyingQuiverAlgebraElement( axg ) ) ) );
            record_with_images_of_morphisms.(axg_string) := ElementaryTensor( g, a, BxA );
        od;
    od;
    
    for b in B_objects do
        for f in A_morphisms do
            fxb := ElementaryTensor( f, b, AxB );
            fxb_string := String( LeadingPath( Representative( UnderlyingQuiverAlgebraElement( fxb ) ) ) );
            record_with_images_of_morphisms.(fxb_string) := ElementaryTensor( b, f, BxA );
        od;
    od;
    
    return CapFunctor( AxB, record_with_images_of_objects, record_with_images_of_morphisms );

end);

##
InstallMethod( NaturalTransformation,
        "for a record and two CAP functors",
        [ IsRecord, IsCapFunctorRep, IsCapFunctorRep ],
        
  function( eta, F, G )
    local nat_tr;
    
    if NamesOfComponents( F ) = [ ] then
        Error( "the record of images is empty\n" );
    fi;
    
    if IsBound( eta.name ) then
        nat_tr := eta.name;
    else
        nat_tr := Concatenation( "Natural transformation from ", Name( F ), " -> ", Name( G ) );
    fi;
    
    nat_tr := NaturalTransformation( nat_tr, F, G );
    
    nat_tr!.defining_record := eta;
    
    AddNaturalTransformationFunction( nat_tr,
      function( source, obj, range )
        return eta.(String( UnderlyingVertex( obj ) ));
      end );
    
    return nat_tr;
    
end );

####################################
#
# View, Print, and Display methods:
#
####################################

##
InstallMethod( ViewObj,
        "for an object in an algebroid",
        [ IsCapCategoryObjectInAlgebroidRep ],

  function( o )
    
    Print( "<", StringView( UnderlyingVertex( o ) ), ">" );
    
end );

###
InstallMethod( ViewObj,
        "for an algebroid",
        [ IsCategoryOfAlgebroidsObject ],

  function( o )
    
    ViewObj( AsCapCategory( o ) );
    Print( " as an object in the category ");
    ViewObj( CapCategory(o) );
    
end );

InstallMethod( Display,
        "for an algebroid",
        [ IsCategoryOfAlgebroidsObject ],

  function( o )
    
    ViewObj( AsCapCategory( o ) );
    Print( " as an object in the category ");
    ViewObj( CapCategory(o) );
    
end );
##
InstallMethod( ViewObj,
        "for a morphism in an algebroid",
        [ IsCapCategoryMorphismInAlgebroidRep ],

  function( o )
    
    if IsRightQuiverAlgebra( UnderlyingQuiverAlgebra( CapCategory( o ) ) ) then
        ViewObj( UnderlyingVertex( Source( o ) ) );
        Print( "-[" );
        ViewObj( UnderlyingQuiverAlgebraElement( o ) );
        Print( "]->" );
        ViewObj( UnderlyingVertex( Range( o ) ) );
    else
        ViewObj( UnderlyingVertex( Range( o ) ) );
        Print( "<-[" );
        ViewObj( UnderlyingQuiverAlgebraElement( o ) );
        Print( "]-" );
        ViewObj( UnderlyingVertex( Source( o ) ) );
    fi;
    
end );
