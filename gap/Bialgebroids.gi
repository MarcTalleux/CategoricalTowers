#
# Bialgebroids: Bialgebroids as preadditive categories generated by enhanced quivers
#
# Implementations
#

####################################
#
# representations:
#
####################################

DeclareRepresentation( "IsCapCategoryObjectInAlgebroidRep",
        IsCapCategoryObjectInAlgebroid and
        IsAttributeStoringRep,
        [ ] );

DeclareRepresentation( "IsCapCategoryMorphismInAlgebroidRep",
        IsCapCategoryMorphismInAlgebroid and
        IsAttributeStoringRep,
        [ ] );

####################################
#
# families and types:
#
####################################

# new families:
BindGlobal( "TheFamilyOfObjectsInAlgebroids",
        NewFamily( "TheFamilyOfObjectsInAlgebroids" ) );

BindGlobal( "TheFamilyOfMorphismsInAlgebroids",
        NewFamily( "TheFamilyOfMorphismsInAlgebroids" ) );

# new types:
BindGlobal( "TheTypeObjectInAlgebroid",
        NewType( TheFamilyOfObjectsInAlgebroids,
                IsCapCategoryObjectInAlgebroidRep ) );

BindGlobal( "TheTypeMorphismInAlgebroid",
        NewType( TheFamilyOfMorphismsInAlgebroids,
                IsCapCategoryMorphismInAlgebroidRep ) );

####################################
#
# methods for attributes:
#
####################################

##
InstallMethod( SetOfObjects,
        "for an algebroid",
        [ IsAlgebroid and HasUnderlyingQuiver ],
        
  A -> List( Vertices( UnderlyingQuiver( A ) ), o -> A.(String( o ) ) ) );

##
InstallMethod( SetOfGeneratingMorphisms,
        "for an algebroid",
        [ IsAlgebroid and HasUnderlyingQuiver ],
        
  A -> List( Arrows( UnderlyingQuiver( A ) ), o -> A.(String( o ) ) ) );

##
InstallMethod( RelationsOfAlgebroid,
        "for an algebroid",
        [ IsAlgebroid and HasUnderlyingQuiverAlgebra ],
        
  function( A )
    local relations;
    
    relations := RelationsOfAlgebra( UnderlyingQuiverAlgebra( A ) );
    
    relations := Filtered( relations, r -> not IsZero( r ) );
    
    return List( relations, MorphismInAlgebroid );
    
end );

##
InstallMethod( BijectionBetweenPairsAndElementaryTensors,
        "for a QPA quiver algebra",
        [ IsQuiverAlgebra ],
        
  function( Qq )
    local Qqq, gens, prod;
    
    if HasPathAlgebra( Qq ) then
        Qq := PathAlgebra( Qq );
    fi;
    
    Qqq := TensorProductOfAlgebras( Qq, Qq );
    
    gens := PrimitivePaths( QuiverOfAlgebra( Qq ) );
    
    gens := Cartesian( gens, gens );
    
    prod := List( gens,
                  p -> ElementaryTensor(
                          PathAsAlgebraElement( Qq, p[1] ),
                          PathAsAlgebraElement( Qq, p[2] ),
                          Qqq ) );
    
    
    prod := List( prod, a -> Paths( Representative( a ) )[1] );
    
    return [ prod, gens ];
    
end );

##
InstallMethod( DecompositionOfMorphismInAlgebroid,
        "for a morphism in an algebroid",
        [ IsCapCategoryMorphismInAlgebroidRep ],
        
  function( mor )
    local B, func;
    
    B := CapCategory( mor );
    
    mor := UnderlyingQuiverAlgebraElement( mor );
    
    mor := DecomposeQuiverAlgebraElement( mor );
    
    func :=
      function( a )
        return List( a,
                     function( f )
                       f := B.(String( f ));
                       if IsCapCategoryObject( f ) then
                           return IdentityMorphism( f );
                       fi;
                       return f;
                     end );
        
      end;
    
    mor[2] := List( mor[2], func );
    
    return ListN( mor[1], mor[2], function( r, s ) return [ r, s ]; end );
    
end );

##
InstallMethod( DecompositionOfMorphismInSquareOfAlgebroid,
        "for a morphism in an algebroid",
        [ IsCapCategoryMorphismInAlgebroidRep ],
        
  function( mor )
    local B, Rq, gens, prod, func;
    
    B := CapCategory( mor )!.PowerOf;
    
    Rq := UnderlyingQuiverAlgebra( B );
    
    gens := BijectionBetweenPairsAndElementaryTensors( Rq );
    prod := gens[2];
    gens := gens[1];
    
    mor := UnderlyingQuiverAlgebraElement( mor );
    
    mor := DecomposeQuiverAlgebraElement( mor );
    
    mor[2] := List( mor[2], p -> List( p, a -> prod[Position( gens, a )] ) );
    
    func :=
      function( a )
        return List( a,
                     function( f )
                       f := B.(String( f ));
                       if IsCapCategoryObject( f ) then
                           return IdentityMorphism( f );
                       fi;
                       return f;
                     end );
        
      end;
    
    mor[2] := List( mor[2], p -> List( p, func ) );
    
    return ListN( mor[1], mor[2], function( r, s ) return [ r, s ]; end );
    
end );

####################################
#
# methods for operation:
#
####################################

##
InstallMethod( DecomposeQuiverAlgebraElement,
        "for a quiver algebra element",
        [ IsQuiverAlgebraElement ],
        
  function( p )
    
    if IsQuotientOfPathAlgebraElement( p ) then
        p := Representative( p );
    fi;
    
    return [ Coefficients( p ),
             List( Paths( p ),
                   function( a )
                     if Length( a ) = 0 then
                         return [ a ];
                     fi;
                     return ArrowList( a );
                   end ) ];
    
end );

##
InstallMethod( ApplyToQuiverAlgebraElement,
        "for a record (of images of objects), a record (of images of morphisms) and a quiver algebra element",
        [ IsRecord, IsRecord, IsQuiverAlgebraElement, IsBool ],
  function( F_objects, F_morphisms, p, contravariant )
    local func_obj, func_mor, applyF, paths, coefs, paths_final, mult_func, s, eval_F_objects, some_object_in_image, all_objects_in_image;
    
    func_obj := b -> F_objects.(String( b ));
    func_mor := b -> F_morphisms.(String( b ));
    
    # function to be applied to an arrow (or a vertex representing the trivial path at this vertex)
    applyF :=
      function( b )
        local m;
        
        if IsVertex( b ) then
            m := func_obj( b );
            return IdentityMorphism( m );
        fi;
        m := func_mor( b );
        
        return m;
        
      end;
    
    paths := DecomposeQuiverAlgebraElement( p );

    coefs := paths[1];
    paths := paths[2];

    
    if contravariant = false then
        paths_final := List( paths, a -> PreCompose( List( a, applyF ) ) );
    else
        paths_final := List( paths, a -> PreCompose( Reversed( List( a, applyF ) ) ) );
    fi;


    if Length( coefs ) > 0 then
      s := Sum( ListN( coefs, paths_final, function( r, p ) return r * p; end ) );
    else
      # construct the zero morphism 
      # FIXME
      eval_F_objects := function(a) return F_objects!.(a); end;
      
      some_object_in_image := List( RecNames(F_objects), eval_F_objects)[1];
      
      all_objects_in_image := SetOfObjects( CapCategory( some_object_in_image ) );

      s := Sum( List( all_objects_in_image, o -> ZeroMorphism(o,o)) );
    fi;
    
    return s;
    
end );

####################################
#
# methods for constructors:
#
####################################

##
InstallGlobalFunction( ADD_FUNCTIONS_FOR_ALGEBROID,
  
  function( category )
    
    ##
    AddIsWellDefinedForObjects( category,
      function( o )
        
        o := UnderlyingVertex( o );
        
        return IsVertex( o ) and IsIdenticalObj( QuiverOfPath( o ), UnderlyingQuiver( category ) );
        
      end );
    
    ##
    AddIsWellDefinedForMorphisms( category,
      function( m )
        
        m := UnderlyingQuiverAlgebraElement( m );
        
        return IsPath( m ) and IsIdenticalObj( QuiverOfPath( m ), UnderlyingQuiver( category ) );
        
      end );
    
    ##
    AddIsEqualForObjects( category,
      function( object_1, object_2 )
        
        return UnderlyingVertex( object_1 ) = UnderlyingVertex( object_2 );
        
    end );
    
    ##
    AddIsEqualForMorphisms( category,
      function( morphism_1, morphism_2 )
        
        return UnderlyingQuiverAlgebraElement( morphism_1 ) = UnderlyingQuiverAlgebraElement( morphism_2 );
        
    end );
    
    ##
    AddIdentityMorphism( category,
      function( object )
        local A;
        
        A := UnderlyingQuiverAlgebra( CapCategory( object ) );
        
        return MorphismInAlgebroid(
                       object,
                       A.(String( UnderlyingVertex( object ) ) ),
                       object );
        
    end );
    
    ##
    AddPreCompose( category,
      function( morphism_1, morphism_2 )
        local B, quiver;
        
        B := CapCategory( morphism_1 );
        
        quiver := UnderlyingQuiver( B );
        
        if IsRightQuiver( quiver ) then
            return MorphismInAlgebroid(
                           Source( morphism_1 ),
                           UnderlyingQuiverAlgebraElement( morphism_1 ) * UnderlyingQuiverAlgebraElement( morphism_2 ),
                           Range( morphism_2 ) );
        else
            return MorphismInAlgebroid(
                           Source( morphism_1 ),
                           UnderlyingQuiverAlgebraElement( morphism_2 ) * UnderlyingQuiverAlgebraElement( morphism_1 ),
                           Range( morphism_2 ) );
        fi;
        
    end );
    
    ##
    AddAdditionForMorphisms( category,
      function( morphism_1, morphism_2 )
        
        return MorphismInAlgebroid(
                       Source( morphism_1 ),
                       UnderlyingQuiverAlgebraElement( morphism_1 ) + UnderlyingQuiverAlgebraElement( morphism_2 ),
                       Range( morphism_1 ) );
        
    end );
    
    ##
    AddAdditiveInverseForMorphisms( category,
      function( morphism )
        
        return MorphismInAlgebroid(
                       Source( morphism ),
                       -UnderlyingQuiverAlgebraElement( morphism ),
                       Range( morphism ) );
        
    end );
    
    #
    AddMultiplyWithElementOfCommutativeRingForMorphisms( category,
      function( r, morphism )
        
        return MorphismInAlgebroid(
                       Source( morphism ),
                       r * UnderlyingQuiverAlgebraElement( morphism ),
                       Range( morphism ) );
        
    end );
    
    ##
    AddZeroMorphism( category,
      function( S, T )
        
        return MorphismInAlgebroid(
                       S,
                       Zero( UnderlyingQuiverAlgebra( CapCategory( S ) ) ),
                       T );
        
    end );
    
    Finalize( category );
    SetFilterObj(IdentityFunctor(category), IsAlgebroidMorphism);
    
    return category;
    
end );

##
InstallMethod( Algebroid,
        "for a QPA quiver algebra",
        [ IsQuiverAlgebra ],
        
  function( Rq )
    local parity, quiver, A;
    
    if IsRightQuiverAlgebra( Rq ) then
        parity := "right";
    else
        parity := "left";
    fi;
    
    quiver := QuiverOfAlgebra( Rq );
    
    if Length( Vertices( quiver ) ) > 1 then
        A := "Algebroid";
    else
        A := "Algebra";
    fi;
    
    A := Concatenation( A, " generated by the ", parity, " quiver ", String( quiver ) );
    
    A := CreateCapCategory( A );
    
    SetIsAbCategory( A, true );
    
    SetIsFinitelyPresentedCategory( A, true );
    SetUnderlyingQuiver( A, quiver );
    SetCommutativeRingOfLinearCategory( A, LeftActingDomain( Rq ) );
    SetUnderlyingQuiverAlgebra( A, Rq );
    SetFilterObj( A, IsAlgebroid );
    if Length( Vertices( quiver ) ) = 1 then
        SetFilterObj( A, IsAlgebraAsCategory );
    fi;
    
    A!.Vertices := rec( );
    A!.Arrows := rec( );
    
    return ADD_FUNCTIONS_FOR_ALGEBROID( A );
    
end );

##
InstallMethod( Algebroid,
        "for a QPA path algebra and a list",
        [ IsPathAlgebra, IsList ],
        
  function( Rq, L )
    local path;
    
    for path in L do
        if not IsUniform( path ) then
            Error( "only uniform relations are admissible, while the path ", path, " is not uniform\n" );
        fi;
    od;
    
    L := Filtered( L, r -> not IsZero( r ) );
    
    return Algebroid( Rq / Ideal( Rq, L ) );
    
end );

##
InstallMethod( Algebroid,
        "for a homalg ring and a QPA quiver",
        [ IsHomalgRing, IsQuiver ],
        
  function( R, quiver )
    
    return Algebroid( PathAlgebra( R, quiver ) );
    
end );

InstallMethod( BaseRing,
        "for an algebroid",
        [ IsAlgebroid ],

  function( A )

    return LeftActingDomain( UnderlyingQuiverAlgebra( A ) );

end );


##
InstallMethod( \.,
        "for an algebroid and a positive integer",
        [ IsAlgebroid, IsPosInt ],
        
  function( B, string_as_int )
    local q, name, a, b;
    
    q := UnderlyingQuiver( B );
    
    name := NameRNam( string_as_int );
    
    a := q.(name);
    
    b := rec( );
    
    if IsVertex( a ) then
        if IsBound( B!.Vertices.(name) ) then
            return B!.Vertices.(name);
        fi;
        ObjectifyWithAttributes( b, TheTypeObjectInAlgebroid,
                UnderlyingVertex, a
                );
        B!.Vertices.(name) := b;
    elif IsArrow( a ) then
        if IsBound( B!.Arrows.(name) ) then
            return B!.Arrows.(name);
        fi;
        b := MorphismInAlgebroid(
                     B.(String( Source( a ) ) ),
                     PathAsAlgebraElement( UnderlyingQuiverAlgebra( B ), a ),
                     B.(String( Target( a ) ) ) );
        B!.Arrows.(name) := b;
    else
        Error( "the given component ", name, " is neither a vertex nor an arrow of the quiver q = ", q, "\n" );
    fi;
    
    Add( B, b );
    
    return b;
     
end );

InstallMethod( ObjectInAlgebroid,
         "for an algebroid and a vertex of a quiver",
        [ IsAlgebroid, IsVertex ],
  function( A, v )
    local o;
    o := rec();
    ObjectifyWithAttributes( o, TheTypeObjectInAlgebroid,
            UnderlyingVertex, v
            );
    
    A!.Vertices.(String(v)) := o;
    Add( A, o );
    return o;
end );

##
InstallMethod( MorphismInAlgebroid,
        "for two objects in an algebroid and an element of the quiver algebra",
        [ IsCapCategoryObjectInAlgebroidRep, IsQuiverAlgebraElement, IsCapCategoryObjectInAlgebroidRep ],
        
  function( S, path, T )
    local l, mor, A;
    
    if not IsZero( path ) then
        
        if not IsUniform( path ) then
            Error( "the path ", path, " is neither zero nor uniform\n" );
        fi;
        
        ## TODO: we are avoiding for the moment the sanity test for
        ## elements of path algebras with relations, this should be
        ## reintroduced in the future
        if IsPathAlgebraElement( path ) then
            l := LeadingPath( path );
            
            if not ( Source( l ) = UnderlyingVertex( S ) and
                     Target( l ) = UnderlyingVertex( T ) ) then
                Error( "the path ", path, " is neither zero nor does it match the given source S or target T\n" );
            fi;
        fi;
        
    fi;
    
    mor := rec( );
    
    if not IsIdenticalObj( CapCategory(S), CapCategory(T) ) then
        Error( "source and target do not belong to the same category");
    fi;

    A := CapCategory( S );
    
    ObjectifyWithAttributes( mor, TheTypeMorphismInAlgebroid,
            Source, S,
            Range, T,
            UnderlyingQuiverAlgebraElement, path
            );
    
    Add( A, mor );
    
    return mor;
    
end );

##
InstallMethod( MorphismInAlgebroid,
        "an element of a path algebra",
        [ IsPathAlgebraElement ],
        
  function( path )
    local A, l, S, T;
    
    if IsZero( path ) then
        Error( "source and target of the zero path is ambiguous\n" );
    elif not IsUniform( path ) then
        Error( "the path ", path, " is not uniform\n" );
    fi;
    
    A := Algebroid( AlgebraOfElement( path ) );
    
    l := LeadingPath( path );
    
    S := String( Source( l ) );
    T := String( Target( l ) );
    
    return MorphismInAlgebroid( A.(S), path, A.(T) );
    
end );

##
InstallMethod( POW,
        "for an algebroid and an integer",
        [ IsAlgebroid and HasUnderlyingQuiverAlgebra, IsInt ],
        
  function( A, n )
    local Rq, R, trivial_quiver, Rqq;
    
    if n < 0 then
        Error( "the only admissible values for n are non-negative integers\n" );
    elif n = 1 then
        return A;
    elif not IsBound( A!.powers ) then
        A!.powers := rec( );
    fi;
    
    Rq := UnderlyingQuiverAlgebra( A );
    
    R := LeftActingDomain( Rq );
    
    if n = 0 then
        
        if not IsBound( A!.powers.0 ) then
            
            if IsRightQuiverAlgebra( Rq ) then
                trivial_quiver := RightQuiver( "*(1)[]" );
            else
                trivial_quiver := LeftQuiver( "*(1)[]" );
            fi;
            
            A!.powers.0 := Algebroid( PathAlgebra( R, trivial_quiver ) );
            
        fi;
        
        return A!.powers.0;
        
    fi;
    
    A!.powers.1 := A;
    
    if not IsBound( A!.powers.(n) ) then
        if not IsBound( A!.powers.(n-1) ) then
            A!.powers.(n-1) := A^(n-1);
        fi;
        
        A!.powers.(n) := A!.powers.(n-1) * A;
        
        A!.powers.(n)!.PowerOf := A;
        
    fi;
    
    return A!.powers.(n);
    
end );

##
InstallMethod(ElementaryTensor,
        "for objects in algebroids",
        [ IsCapCategoryObjectInAlgebroid, IsCapCategoryObjectInAlgebroid, IsAlgebroid ],
  function( a, b, T )
      
    local product_string, a_string, b_string, product_vertex;
  
    product_vertex := PathInProductQuiver( QuiverOfAlgebra( UnderlyingQuiverAlgebra( T ) ), [ UnderlyingVertex( a ), UnderlyingVertex( b ) ] );
    product_string := String(product_vertex);
  
    return T.(product_string);
end);

##
InstallMethod(ElementaryTensor,
        "for object and morphism in algebroids",
        [ IsCapCategoryObjectInAlgebroid, IsCapCategoryMorphismInAlgebroid, IsAlgebroid ],
  function( object, morphism, T )
    local product_string, coeffs, paths, object_string, sum, i, source, range, morphism_as_quiver_algebra_element, object_underlying_vertex, mors, algebroid_of_morphism, o, product_of_arrows_as_morphism, b, arrows_of_path;

    source := ElementaryTensor( object, Source(morphism), T );
    range := ElementaryTensor( object, Range(morphism), T );

    morphism_as_quiver_algebra_element := UnderlyingQuiverAlgebraElement( morphism );
    
    if IsQuotientOfPathAlgebraElement( morphism_as_quiver_algebra_element ) then
    
        morphism_as_quiver_algebra_element := Representative( morphism_as_quiver_algebra_element );
    
    fi;
    
    if IsZero(morphism_as_quiver_algebra_element) then
      
        return ZeroMorphism( source, range );

    else

        paths := Paths( morphism_as_quiver_algebra_element );
        coeffs := Coefficients( morphism_as_quiver_algebra_element );

        object_underlying_vertex := UnderlyingVertex( object );
        object_string := String( object_underlying_vertex );
       
        sum := ZeroMorphism( source, range );
        
        for i in [1..Length(paths)] do
          
            arrows_of_path := ArrowList( paths[i] ) ;
            
            mors := List( List( arrows_of_path, b -> PathInProductQuiver( QuiverOfAlgebra( UnderlyingQuiverAlgebra( T ) ), [ object_underlying_vertex, b ] ) ), b -> MorphismInAlgebroid( ObjectInAlgebroid( T, Source( b ) ), QuiverAlgebraElement( UnderlyingQuiverAlgebra( T ), [ 1 ], [ b ] ), ObjectInAlgebroid( T, Target( b ) ) ) );
            
            if Length( mors ) > 0 then
              
                product_of_arrows_as_morphism := PreCompose( mors );
              
            else
              
                Assert( 3, IsVertex( paths[i] ) );
                
                algebroid_of_morphism := CapCategory( morphism );
                
                o := ObjectInAlgebroid( algebroid_of_morphism, paths[i] );
                
                Assert( 3, o = Source( morphism ) and o = Range( morphism ) );
                
                product_of_arrows_as_morphism := IdentityMorphism( ElementaryTensor( object, o, T ) );
              
            fi;
            
            sum := sum + coeffs[i] * product_of_arrows_as_morphism;
          
        od;
        
        return sum;
      
    fi;
end );

##
InstallMethod(ElementaryTensor,
        "for morphism and object in algebroids",
        [ IsCapCategoryMorphismInAlgebroid, IsCapCategoryObjectInAlgebroid, IsAlgebroid ],
  function( morphism, object, T )
    local product_string, morphism_as_quiver_algebra_element, coeffs, paths, object_string, sum, i, source, range, object_underlying_vertex, mors, o, algebroid_of_morphism, product_of_arrows_as_morphism, arrows_of_path;

    source := ElementaryTensor( Source( morphism ), object, T );
    range := ElementaryTensor( Range( morphism ), object, T );
    
    morphism_as_quiver_algebra_element := UnderlyingQuiverAlgebraElement( morphism );

    if IsQuotientOfPathAlgebraElement( morphism_as_quiver_algebra_element ) then

        morphism_as_quiver_algebra_element := Representative( morphism_as_quiver_algebra_element );

    fi;

    if IsZero( morphism_as_quiver_algebra_element ) then

        return ZeroMorphism( source, range );

    else

        paths := Paths( morphism_as_quiver_algebra_element );
        coeffs := Coefficients( morphism_as_quiver_algebra_element );

        object_underlying_vertex := UnderlyingVertex( object );
        object_string := String( object_underlying_vertex );
       
        sum := ZeroMorphism( source, range );

        for i in [1..Length( paths )] do

            arrows_of_path := ArrowList( paths[ i ] );
                    
            mors := List( List( arrows_of_path, a -> PathInProductQuiver( QuiverOfAlgebra( UnderlyingQuiverAlgebra( T ) ), [ a, object_underlying_vertex ] ) ), a -> MorphismInAlgebroid( ObjectInAlgebroid( T, Source(a) ), QuiverAlgebraElement(UnderlyingQuiverAlgebra(T), [1], [a]), ObjectInAlgebroid(T, Target(a)) ) );

            if Length(mors) > 0 then

                product_of_arrows_as_morphism := PreCompose( mors );

            else

                Assert( 3, IsVertex( paths[i] ) );

                algebroid_of_morphism := CapCategory( morphism );

                o := ObjectInAlgebroid( algebroid_of_morphism, paths[i] );

                Assert( 3, o = Source( morphism ) and o = Range( morphism ) );

                product_of_arrows_as_morphism := IdentityMorphism( ElementaryTensor( o, object, T ) );
       
            fi;

            sum := sum + coeffs[i] * product_of_arrows_as_morphism;
            
        od;
        
        return sum;

    fi;
end );

##
InstallMethod(TensorProductOnObjects,
        "for algebroids",
        [ IsAlgebroid, IsAlgebroid ],
  function( X, Y )

    return X * Y;

end );

##
InstallMethod( \*,
        "for two algebroids",
        [ IsAlgebroid and HasUnderlyingQuiverAlgebra, IsAlgebroid and HasUnderlyingQuiverAlgebra ],
        
  function( A, B )
    return Algebroid( TensorProductOfAlgebras( UnderlyingQuiverAlgebra( A ), UnderlyingQuiverAlgebra( B ) ) );
end );

##
InstallMethod( CapFunctor,
        "for an algebroid and two records",
        [ IsAlgebroid, IsRecord, IsRecord ],
        
  function( A, ImagesOfObjects, ImagesOfMorphisms )
    local b, Rq, B, functor, names_morphisms, names_objects;
    
    names_morphisms := NamesOfComponents( ImagesOfMorphisms );
    names_objects := NamesOfComponents( ImagesOfObjects );
    
    if names_objects = [ ] then
        Error( "the record of images of objects is empty\n" );
    fi;

    # Construct the target category B
    if Length(names_morphisms) > 0 then
        for b in names_morphisms do
            if IsQuiverAlgebraElement( ImagesOfMorphisms.(b) ) then
                Rq := AlgebraOfElement( ImagesOfMorphisms.(b) );
                B := Algebroid( Rq );
                break;
            elif IsCapCategoryCell( ImagesOfMorphisms.(b) ) then
                if not IsCapCategoryMorphism( ImagesOfMorphisms.(b) ) then
                    Error( Concatenation( "image of ", String(b), " is not a morphism"));
                fi;

                B := CapCategory( ImagesOfMorphisms.(b) );
                break;
            fi;
        od;
    else
        B := CapCategory( ImagesOfObjects.(names_objects[1]) );
    fi;

    if not IsBound( B ) then
        Error( "unable to extract target category from the records of images\n" );
    fi;
    
    functor := Concatenation( "Functor from finitely presented ", Name( A ), " -> ", Name( B ) );
   
    functor := CapFunctor( functor, A, B );
    
    AddObjectFunction( functor,
            obj -> ImagesOfObjects.(String( UnderlyingVertex( obj ) )) );
    
    AddMorphismFunction( functor,
            function( new_source, mor, new_range )
              if IsBound( functor!.IsContravariant ) and functor!.IsContravariant then
                  return ApplyToQuiverAlgebraElement( ImagesOfObjects, ImagesOfMorphisms, UnderlyingQuiverAlgebraElement( mor ), true);
              else
                  return ApplyToQuiverAlgebraElement( ImagesOfObjects, ImagesOfMorphisms, UnderlyingQuiverAlgebraElement( mor ), false );
              fi;
            end );
    
    SetFilterObj( functor, IsAlgebroidMorphism );
    
    return functor;
    
end );

##
InstallMethod( AddBialgebroidStructure,
        "for an algebroid and two records",
        [ IsAlgebroid, IsRecord, IsRecord ],
        
  function( B, counit_images, comult_images )
    local vertices, B0, counit_record_morphisms, counit_record_objects, counit_functor, B2, comult_record_morphisms, comult_record_objects, comult_functor, a;
    
    B!.Name := Concatenation( "Bia", B!.Name{[ 2 .. Length( B!.Name ) ]} );
    
    vertices := List( Vertices( UnderlyingQuiver( B ) ), String );
    
    B0 := B^0;
    
    # Construct the counit as a CapFunctor from B to B^0
    
    counit_record_morphisms := ShallowCopy( counit_images );
    counit_record_objects := rec();
  
    for a in NamesOfComponents( counit_images ) do
        if not IsCapCategoryMorphism( counit_images.(a) ) then
            counit_record_morphisms.(a) := counit_images.(a) * IdentityMorphism( B0.1 );
        fi;
    od;
    
    ## we know how to map the objects
    for a in vertices do
        counit_record_objects.(a) := B0.1;
    od;
   
    counit_functor := CapFunctor( B, counit_record_objects, counit_record_morphisms );
    
    if not IsIdenticalObj( B0, AsCapCategory( Range( counit_functor ) ) ) then
        Error( "counit_functor has a the wrong target category\n" );
    fi;
    
    SetCounit( B, counit_functor );
    
    B2 := B^2;
    
    # Construct the comultiplication as a CapFunctor from B to B^2
   
    comult_record_morphisms := ShallowCopy( comult_images );
    comult_record_objects := rec();
    
    ## we know how to map the objects
    for a in vertices do
        comult_record_objects.(a) := ElementaryTensor( B.(a), B.(a), B2 );
    od;
    
    comult_functor := CapFunctor( B, comult_record_objects, comult_record_morphisms );
    
    if not IsIdenticalObj( B2, AsCapCategory( Range( comult_functor ) ) ) then
        Error( "comult_functor has a the wrong target category\n" );
    fi;
    
    SetComultiplication( B, comult_functor );
    
    return B;
    
end );

##
InstallMethod( Opposite,
        "for an algebroid",
        [ IsAlgebroid and HasUnderlyingQuiver ],
        
  function( A )
    local q_op, R, A_op;
    
    q_op := OppositeQuiver( UnderlyingQuiver( A ) );
    
    R := LeftActingDomain( UnderlyingQuiverAlgebra( A ) );
    
    A_op := Algebroid( R, q_op );
    
    SetOpposite( A_op, A );
    
    return A_op;
    
end );

##
InstallMethod( AddAntipode,
        "for a CAP category and a record",
        [ IsAlgebroid, IsRecord ],
        
  function( B, S_images_of_morphisms )
    local vertices, S_images_of_objects, S_functor, a;
    
    if IsAlgebraAsCategory(B) then
        B!.Name := Concatenation( "Hopf algebra", B!.Name{[ 10 .. Length( B!.Name ) ]} );
    else
        B!.Name := Concatenation( "Hopf algebroid", B!.Name{[ 10 .. Length( B!.Name ) ]} );
    fi;
    
    vertices := List( Vertices( UnderlyingQuiver( B ) ), String );
    
    S_images_of_objects := rec();
    for a in vertices do
        S_images_of_objects.(a) := B.(a);
    od;

    S_functor := CapFunctor( B, S_images_of_objects, S_images_of_morphisms );
    S_functor!.IsContravariant := true;
    
    S_functor!.Name := Concatenation( "Contravariant f", S_functor!.Name{[ 2 .. Length( S_functor!.Name ) ]} );
    
    if not IsIdenticalObj( B, AsCapCategory( Range( S_functor ) ) ) then
        Error( "S_functor has a the wrong target category\n" );
    fi;
    
    SetAntipode( B, S_functor );
    
end );

##
InstallMethod( IsCommutative,
        "for an Algebroid",
        [ IsAlgebroid ],
     
  function( A )
    local arrows, i, j;
    
    arrows := Arrows( UnderlyingQuiverAlgebra( A ) );
    
    for i in [ 1 .. Length(arrows) ] do
      for j in [ (i+1) .. Length(arrows) ] do
        if not arrows[i]*arrows[j] = arrows[j]*arrows[i] then
          return false;
        fi;
      od;
    od;
    
    return true;
end );

##
InstallMethod( NaturalTransformation,
        "for a record and two CAP functors",
        [ IsRecord, IsCapFunctorRep, IsCapFunctorRep ],
        
  function( eta, F, G )
    local nat_tr;
    
    if NamesOfComponents( F ) = [ ] then
        Error( "the record of images is empty\n" );
    fi;
    
    if IsBound( eta.name ) then
        nat_tr := eta.name;
    else
        nat_tr := Concatenation( "Natural transformation from ", Name( F ), " -> ", Name( G ) );
    fi;
    
    nat_tr := NaturalTransformation( nat_tr, F, G );
    
    nat_tr!.defining_record := eta;
    
    AddNaturalTransformationFunction( nat_tr,
      function( source, obj, range )
        return eta.(String( UnderlyingVertex( obj ) ));
      end );
    
    return nat_tr;
    
end );

####################################
#
# View, Print, and Display methods:
#
####################################

##
InstallMethod( ViewObj,
        "for an object in an algebroid",
        [ IsCapCategoryObjectInAlgebroidRep ],

  function( o )
    
    ViewObj( UnderlyingVertex( o ) );
    
end );

##
InstallMethod( ViewObj,
        "for a morphism in an algebroid",
        [ IsCapCategoryMorphismInAlgebroidRep ],

  function( o )
    
    if IsRightQuiverAlgebra( UnderlyingQuiverAlgebra( CapCategory( o ) ) ) then
        ViewObj( Source( o ) );
        Print( "-[" );
        ViewObj( UnderlyingQuiverAlgebraElement( o ) );
        Print( "]->" );
        ViewObj( Range( o ) );
    else
        ViewObj( Range( o ) );
        Print( "<-[" );
        ViewObj( UnderlyingQuiverAlgebraElement( o ) );
        Print( "]-" );
        ViewObj( Source( o ) );
    fi;
    
end );
