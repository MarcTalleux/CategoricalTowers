# SPDX-License-Identifier: GPL-2.0-or-later
# Algebroids: Algebroids and bialgebroids as preadditive categories generated by enhanced quivers
#
# Implementations
#

# additive_closure_object[i] => ObjectList( additive_closure_object )[i]
CapJitAddLogicTemplate(
    rec(
        variable_names := [ "additive_closure_object", "index" ],
        variable_filters := [ IsAdditiveClosureObject, IsInt ],
        src_template := "additive_closure_object[index]",
        dst_template := "ObjectList( additive_closure_object )[index]",
        returns_value := true,
    )
);

# additive_closure_morphism[i, j] => MorphismMatrix( additive_closure_morphism )[i, j]
CapJitAddLogicTemplate(
    rec(
        variable_names := [ "additive_closure_morphism", "row", "column" ],
        variable_filters := [ IsAdditiveClosureMorphism, IsInt, IsInt ],
        src_template := "additive_closure_morphism[row, column]",
        dst_template := "MorphismMatrix( additive_closure_morphism )[row][column]",
        returns_value := true,
    )
);

# NumberRows( additive_closure_morphism ) => Length( ObjectList( Source( additive_closure_morphism ) ) )
CapJitAddLogicTemplate(
    rec(
        variable_names := [ "additive_closure_morphism" ],
        variable_filters := [ IsAdditiveClosureMorphism ],
        src_template := "NumberRows( additive_closure_morphism )",
        dst_template := "Length( ObjectList( Source( additive_closure_morphism ) ) )",
        returns_value := true,
    )
);

# NumberColumns( additive_closure_morphism ) => Length( ObjectList( Range( additive_closure_morphism ) ) )
CapJitAddLogicTemplate(
    rec(
        variable_names := [ "additive_closure_morphism" ],
        variable_filters := [ IsAdditiveClosureMorphism ],
        src_template := "NumberColumns( additive_closure_morphism )",
        dst_template := "Length( ObjectList( Range( additive_closure_morphism ) ) )",
        returns_value := true,
    )
);

CapJitAddLogicTemplate(
    rec(
        variable_names := [ "nr_rows1", "list", "condA", "condB", "nr_rows2", "nr_cols", "value" ],
        src_template := """
            return UnionOfColumnsListList( nr_rows1, List( list, function( l )
                if condA or condB then
                    return NullMatImmutable( nr_rows2, nr_cols );
                else
                    return value;
                fi;
            end ) );
        """,
        dst_template := """
            if condA then
                return NullMatImmutable( nr_rows1, Sum( list, l -> nr_cols ) );
            else
                return UnionOfColumnsListList( nr_rows1, List( list, function( l )
                    if condB then
                        return NullMatImmutable( nr_rows2, nr_cols );
                    else
                        return value;
                    fi;
                end ) );
            fi;
        """,
        returns_value := false,
        needed_packages := [ [ "FreydCategoriesForCAP", ">= 2021.12-02" ] ],
    )
);

CapJitAddLogicTemplate(
    rec(
        variable_names := [ "nr_cols1", "list", "condA", "condB", "nr_rows", "nr_cols2", "value" ],
        src_template := """
            return UnionOfRowsListList( nr_cols1, List( list, function( l )
                if condA or condB then
                    return NullMatImmutable( nr_rows, nr_cols2 );
                else
                    return value;
                fi;
            end ) );
        """,
        dst_template := """
            if condA then
                return NullMatImmutable( Sum( list, l -> nr_rows ), nr_cols1 );
            else
                return UnionOfRowsListList( nr_cols1, List( list, function( l )
                    if condB then
                        return NullMatImmutable( nr_rows, nr_cols2 );
                    else
                        return value;
                    fi;
                end ) );
            fi;
        """,
        returns_value := false,
        needed_packages := [ [ "FreydCategoriesForCAP", ">= 2021.12-02" ] ],
    )
);

# EntriesOfHomalgMatrixAsListList( HomalgMatrixListList( listlist ) ) => listlist
CapJitAddLogicTemplate(
    rec(
        variable_names := [ "listlist", "nr_rows", "nr_cols", "ring" ],
        src_template := "EntriesOfHomalgMatrixAsListList( HomalgMatrixListList( listlist, nr_rows, nr_cols, ring ) )",
        dst_template := "listlist",
        returns_value := true,
        needed_packages := [ [ "MatricesForHomalg", ">= 2021.12-01" ] ],
    )
);

# Length( ListWithIdenticalEntries( number, obj ) ) => number
CapJitAddLogicTemplate(
    rec(
        variable_names := [ "number", "obj" ],
        src_template := "Length( ListWithIdenticalEntries( number, obj ) )",
        dst_template := "number",
        returns_value := true,
    )
);

# List( L, x -> x ) => L
CapJitAddLogicTemplate(
    rec(
        variable_names := [ "list" ],
        src_template := "List( list, x -> x )",
        dst_template := "list",
        returns_value := true,
    )
);

# UnionOfRowsListList
CapJitAddLogicTemplate(
    rec(
        variable_names := [ "nr_cols", "listlist", "func" ],
        src_template := "List( UnionOfRowsListList( nr_cols, listlist ), row -> List( row, func ) )",
        dst_template := "UnionOfRowsListList( nr_cols, List( listlist, list -> List( list, new_row -> List( new_row, func ) ) ) )",
        new_funcs := [ [ "list" ], [ "new_row" ] ],
        returns_value := true,
        needed_packages := [ [ "FreydCategoriesForCAP", ">= 2021.12-02" ] ],
    )
);

# UnionOfColumnsListList
CapJitAddLogicTemplate(
    rec(
        variable_names := [ "nr_rows", "listlist", "func" ],
        src_template := "List( UnionOfColumnsListList( nr_rows, listlist ), row -> List( row, func ) )",
        dst_template := "UnionOfColumnsListList( nr_rows, List( listlist, list -> List( list, new_row -> List( new_row, func ) ) ) )",
        new_funcs := [ [ "list" ], [ "new_row" ] ],
        returns_value := true,
        needed_packages := [ [ "FreydCategoriesForCAP", ">= 2021.12-02" ] ],
    )
);
