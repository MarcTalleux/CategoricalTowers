# SPDX-License-Identifier: GPL-2.0-or-later
# Toposes: Elementary toposes
#
# Implementations
#

##
AddDerivationToCAP( SubobjectOfClassifyingMorphism,
                    [ [ TruthMorphismOfTrueWithGivenObjects , 1 ],
                      [ ProjectionInFactorOfFiberProduct , 1 ] ],
  function( cat, mor )
    local truth, subobject;
    
    truth := TruthMorphismOfTrueWithGivenObjects(
                     cat,
                     TerminalObject( cat ),
                     SubobjectClassifier( cat ) );
    
    subobject := ProjectionInFactorOfFiberProduct( cat, [ mor, truth ], 1 );
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    Assert( 4, IsMonomorphism( subobject ) );
    #% CAP_JIT_DROP_NEXT_STATEMENT
    SetIsMonomorphism( subobject, true );
    
    return subobject;
    
end : Description := "SubobjectOfClassifyingMorphism using the fiber product along the true morphism" );

##
AddDerivationToCAP( CartesianSquareOfSubobjectClassifier,
  function( cat )
    local Omega;
    
    Omega := SubobjectClassifier( cat );
    
    return DirectProduct( cat, [ Omega, Omega ] );
    
end );

## [Goldblatt 1984: Topoi - The categorical analysis of logic, Exercise 4.2.1]
## ‚ä§: ùüô ‚Ü™ Œ© classfies id_ùüô: ùüô ‚Ü™ ùüô
AddDerivationToCAP( TruthMorphismOfTrueWithGivenObjects,
  function( cat, T, Omega )
    
    return ClassifyingMorphismOfSubobjectWithGivenSubobjectClassifier(
                   cat,
                   IdentityMorphism( cat, T ),
                   Omega );
    
end );

## [Goldblatt 1984: Topoi - The categorical analysis of logic, Section 5.4 (False)]
## ‚ä•: ùüô ‚Ü™ Œ© classifies ‚àÖ ‚Ü™ ùüô
AddDerivationToCAP( TruthMorphismOfFalseWithGivenObjects,
  function( cat, T, Omega )
    
    return ClassifyingMorphismOfSubobjectWithGivenSubobjectClassifier(
                   cat,
                   UniversalMorphismIntoTerminalObjectWithGivenTerminalObject( cat, InitialObject( cat ), T ),
                   Omega );
    
end );

## [Goldblatt 1984: Topoi - The categorical analysis of logic, Section 6.6 (Truth-arrows in a topos)]
## ¬¨: Œ© ‚Üí Œ© classifies ‚ä•: ùüô ‚Ü™ Œ©
AddDerivationToCAP( TruthMorphismOfNotWithGivenObjects,
  function( cat, Omega, Omega1 )
    local T;
    
    T := TerminalObject( cat );
    
    return ClassifyingMorphismOfSubobjectWithGivenSubobjectClassifier(
                   cat,
                   TruthMorphismOfFalseWithGivenObjects( cat, T, Omega ),
                   Omega );
    
end );

## [Goldblatt 1984: Topoi - The categorical analysis of logic, Section 6.6 (Truth-arrows in a topos)]
## ‚àß: Œ© √ó Œ© ‚Üí Œ© classifies the product morphism ‚ü® ‚ä§, ‚ä§ ‚ü©: ùüô ‚Ü™ Œ© √ó Œ© of twice the morphism ‚ä§: ùüô ‚Ü™ Œ©
AddDerivationToCAP( TruthMorphismOfAndWithGivenObjects,
  function( cat, Omega2, Omega )
    local T, t;
    
    T := TerminalObject( cat );
    
    t := TruthMorphismOfTrueWithGivenObjects( cat, T, Omega );
    
    return ClassifyingMorphismOfSubobjectWithGivenSubobjectClassifier(
                   cat,
                   UniversalMorphismIntoDirectProductWithGivenDirectProduct(
                           cat,
                           [ Omega, Omega ],
                           T,
                           [ t, t ],
                           Omega2 ),
                   Omega );
    
end );

## [Goldblatt 1984: Topoi - The categorical analysis of logic, Section 6.6 (Truth-arrows in a topos)]
## ‚à®: Œ© √ó Œ© ‚Üí Œ© classifies [ ‚ü®‚ä§_Œ©,id_Œ©‚ü©, ‚ü®id_Œ©,‚ä§_Œ©‚ü© ]: Œ© ‚äî Œ© ‚Ü™ Œ© √ó Œ©
AddDerivationToCAP( TruthMorphismOfOrWithGivenObjects,
  function( cat, Omega2, Omega )
    local T, t, id, left, right;
    
    T := TerminalObject( cat );
    
    ## ‚ä§_Œ©: Œ© ‚Üí ùüô ‚Üí Œ© is the morphism classifying the full subobject of Œ©, i.e.,
    ## ‚ä§_Œ© = ClassifyingMorphismOfSubobject( IdentityMorphism( Omega ) )
    t := PreCompose(
                 cat,
                 UniversalMorphismIntoTerminalObjectWithGivenTerminalObject( cat, Omega, T ),
                 TruthMorphismOfTrueWithGivenObjects( cat, T, Omega ) );
    
    id := IdentityMorphism( cat, Omega );
    
    left := UniversalMorphismIntoDirectProductWithGivenDirectProduct(
                    cat,
                    [ Omega, Omega ],
                    Omega,
                    [ t, id ],
                    Omega2 );
    
    right := UniversalMorphismIntoDirectProductWithGivenDirectProduct(
                     cat,
                     [ Omega, Omega ],
                     Omega,
                     [ id, t ],
                     Omega2 );
    
    return ClassifyingMorphismOfSubobjectWithGivenSubobjectClassifier(
                   cat,
                   UniversalMorphismFromCoproduct(
                           cat,
                           [ Omega, Omega ],
                           Omega2,
                           [ left, right ] ),
                   Omega );
    
end );

## ‚áí: Œ© √ó Œ© ‚Üí Œ© classifies the equalizer embedding E ‚Ü™ Œ© √ó Œ© of (‚àß: Œ© √ó Œ© ‚Üí Œ©, œÄ_1: Œ© √ó Œ© ‚Üí Œ©)
AddDerivationToCAP( TruthMorphismOfImpliesWithGivenObjects,
  function( cat, Omega2, Omega )
    
    return ClassifyingMorphismOfSubobjectWithGivenSubobjectClassifier(
                   cat,
                   EmbeddingOfEqualizer(
                           cat,
                           [ TruthMorphismOfAndWithGivenObjects( cat, Omega2, Omega ),
                             ProjectionInFactorOfDirectProductWithGivenDirectProduct(
                                     cat,
                                     [ Omega, Omega ],
                                     1,
                                     Omega2
                                     ) ] ),
                   Omega );
    
end );

## Note that |Sub(Œ©)| = |End(Œ©)|
## * but id_Œ© ‚âú ‚ä§_Œ© ‚àà Sub(Œ©) does not correspond to id_Œ© ‚àà End(Œ©) but to ‚ä§_Œ©: Œ© ‚Üí ùüô ‚Üí Œ© ‚àà End(Œ©), which is generally not an iso
## * and id_Œ© ‚àà End(Œ©) corresponds to ‚ä§: ùüô ‚Üí Œ©

## -Œπ is an operation Sub(Œ©) ‚Üí Sub(Œ©) induced by ¬¨: Œ© ‚Üí Œ©
## Theorem: -Œπ = ( Œπ ‚áí ‚ä•_Sub(Œ©) )
AddDerivationToCAP( EmbeddingOfPseudoComplementSubobject,
  function( cat, iota ) # Œπ: S ‚Ü™ M
    
    return SubobjectOfClassifyingMorphism( ## -Œπ: (S - M) ‚Ü™ M
                   cat,
                   PreCompose(
                           cat,
                           ClassifyingMorphismOfSubobject( cat, iota ), ## œá_Œπ: M ‚Üí Œ©
                           TruthMorphismOfNot( cat ) ## ¬¨: Œ© ‚Üí Œ©
                           ) );
    
end );

##
AddDerivationToCAP( PseudoComplementSubobject,
  function( cat, iota )
    
    return Source( EmbeddingOfPseudoComplementSubobject( cat, iota ) );
    
end );

## Œπ1 ‚àß Œπ2 is an operation Sub(Œ©) √ó Sub(Œ©) ‚Üí Sub(Œ©) induced by ‚àß: Œ© √ó Œ© ‚Üí Œ©,
## however, we instead use the finite completeness and finite cocompletenss of the topos (see next method)
AddDerivationToCAP( EmbeddingOfIntersectionSubobject,
  function( cat, iota1, iota2 )
    local Omega;
    
    Omega := SubobjectClassifier( cat );
    
    return SubobjectOfClassifyingMorphism( ## -Œπ
                   cat,
                   PreCompose(
                           UniversalMorphismIntoDirectProduct( ## Range( Œπ1 ) = Range( Œπ2 ) ‚Üí Œ© √ó Œ©
                                   cat,
                                   [ Omega, Omega ],
                                   Range( iota1 ),
                                   [ ClassifyingMorphismOfSubobject( cat, iota1 ), ## œá_Œπ1
                                     ClassifyingMorphismOfSubobject( cat, iota2 ) ] ), ## œá_Œπ2
                           TruthMorphismOfAnd( cat ) ## ‚àß: Œ© √ó Œ© ‚Üí Œ©
                           ) );
    
end );

## [Goldblatt 1984: Topoi - The categorical analysis of logic, Theorem 7.1.2]
AddDerivationToCAP( EmbeddingOfIntersectionSubobject,
  function( cat, iota1, iota2 )
    local subobject;
    
    subobject := MorphismFromFiberProductToSink( cat, [ iota1, iota2 ] );
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    Assert( 4, IsMonomorphism( subobject ) );
    #% CAP_JIT_DROP_NEXT_STATEMENT
    SetIsMonomorphism( subobject, true );
    
    return subobject;
    
end );

##
AddDerivationToCAP( IntersectionSubobject,
  function( cat, iota1, iota2 )
    
    return Source( EmbeddingOfIntersectionSubobject( cat, iota1, iota2 ) );
    
end );

## Œπ1 ‚à® Œπ2 is an operation Sub(Œ©) √ó Sub(Œ©) ‚Üí Sub(Œ©) induced by ‚à®: Œ© √ó Œ© ‚Üí Œ©
## however, we instead use the finite completeness and finite cocompletenss of the topos (see next method)
AddDerivationToCAP( EmbeddingOfUnionSubobject,
  function( cat, iota1, iota2 )
    local Omega;
    
    Omega := SubobjectClassifier( cat );
    
    return SubobjectOfClassifyingMorphism( ## -Œπ
                   cat,
                   PreCompose(
                           UniversalMorphismIntoDirectProduct( ## Range( Œπ1 ) = Range( Œπ2 ) ‚Üí Œ© √ó Œ©
                                   cat,
                                   [ Omega, Omega ],
                                   Range( iota1 ),
                                   [ ClassifyingMorphismOfSubobject( cat, iota1 ), ## œá_Œπ1
                                     ClassifyingMorphismOfSubobject( cat, iota2 ) ] ), ## œá_Œπ2
                           TruthMorphismOfOr( cat ) ## ‚à®: Œ© √ó Œ© ‚Üí Œ©
                           ) );
    
end );

## [Goldblatt 1984: Topoi - The categorical analysis of logic, Theorem 7.1.3]
AddDerivationToCAP( EmbeddingOfUnionSubobject,
  function( cat, iota1, iota2 )
    
    return ImageEmbedding(
                   cat,
                   UniversalMorphismFromCoproduct(
                           cat,
                           [ Source( iota1 ), Source( iota2 ) ],
                           Range( iota1 ),
                           [ iota1, iota2 ] ) );  ## [ Œπ1, Œπ2 ] : Source( Œπ1 ) ‚äî Source( Œπ2 ) ‚Üí Range( Œπ1 )
    
end );

##
AddDerivationToCAP( UnionSubobject,
  function( cat, iota1, iota2 )
    
    return Source( EmbeddingOfUnionSubobject( cat, iota1, iota2 ) );
    
end );

## Œπ1 ‚áí Œπ2 is an operation Sub(Œ©) √ó Sub(Œ©) ‚Üí Sub(Œ©) induced by ‚áí: Œ© √ó Œ© ‚Üí Œ©
AddDerivationToCAP( EmbeddingOfRelativePseudoComplementSubobject,
  function( cat, iota1, iota2 )
    local Omega;
    
    Omega := SubobjectClassifier( cat );
    
    return SubobjectOfClassifyingMorphism( ## -Œπ
                   cat,
                   PreCompose(
                           cat,
                           UniversalMorphismIntoDirectProduct( ## Range( Œπ1 ) = Range( Œπ2 ) ‚Üí Œ© √ó Œ©
                                   cat,
                                   [ Omega, Omega ],
                                   Range( iota1 ),
                                   [ ClassifyingMorphismOfSubobject( cat, iota1 ), ## œá_Œπ1
                                     ClassifyingMorphismOfSubobject( cat, iota2 ) ] ), ## œá_Œπ2
                           TruthMorphismOfImplies( cat ) ## ‚áí: Œ© √ó Œ© ‚Üí Œ©
                           ) );
    
end );

##
AddDerivationToCAP( RelativePseudoComplementSubobject,
  function( cat, iota1, iota2 )
    
    return Source( EmbeddingOfRelativePseudoComplementSubobject( cat, iota1, iota2 ) );
    
end );

##
AddDerivationToCAP( ListOfSubobjects,
  function( cat, A )
    local Omega, chis;
    
    Omega := SubobjectClassifier( cat );
    
    chis := MorphismsOfExternalHom( cat, A, Omega );
    
    return List( chis,
                 chi -> SubobjectOfClassifyingMorphism( cat, chi ) );
    
end );


##
AddDerivationToCAP( MorphismsOfExternalHom,
                    [ [ HomomorphismStructureOnObjects, 1 ],
                      [ DistinguishedObjectOfHomomorphismStructure, 1 ],
                      [ InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism, 2 ] ],
  function ( cat, A, B )
    local hom_A_B, D, morphisms;
    
    hom_A_B := HomomorphismStructureOnObjects( cat, A, B );
    
    D := DistinguishedObjectOfHomomorphismStructure( cat );
    
    morphisms := MorphismsOfExternalHom( RangeCategoryOfHomomorphismStructure( cat ),
                         D, hom_A_B );
    
    return List( morphisms,
                 phi -> InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( cat,
                         A,
                         B,
                         phi ) );
    
end :
  ConditionsListComplete := true,
  CategoryFilter := function( cat )
    local B, conditions;
    
    if HasRangeCategoryOfHomomorphismStructure( cat ) then
        
        B := RangeCategoryOfHomomorphismStructure( cat );
        
        conditions := [
          "MorphismsOfExternalHom",
        ];
        
        if ForAll( conditions, c -> CanCompute( B, c ) ) then
            
            return true;
            
        fi;
        
    fi;
    
    return false;
    
  end,
  Description := "MorphismsOfExternalHom using MorphismsOfExternalHom in RangeCategoryOfHomomorphismStructure" );

## Final derivations

##
AddFinalDerivation( CanonicalIdentificationFromImageObjectToCoimage,
                    [ [ ImageObject, 1 ],
                      [ IdentityMorphism, 1 ] ],
                    [ CanonicalIdentificationFromCoimageToImageObject,
                      CanonicalIdentificationFromImageObjectToCoimage,
                      CoimageObject,
                      CoimageProjection,
                      CoimageProjectionWithGivenCoimageObject,
                      AstrictionToCoimage,
                      AstrictionToCoimageWithGivenCoimageObject,
                      UniversalMorphismIntoCoimage,
                      UniversalMorphismIntoCoimageWithGivenCoimageObject,
                      IsomorphismFromCoimageToCokernelOfKernel,
                      IsomorphismFromCokernelOfKernelToCoimage ],
                    
  function( cat, mor )
    
    return IdentityMorphism( cat, ImageObject( cat, mor ) );
    
  end,
  [
    CanonicalIdentificationFromCoimageToImageObject,
    function( cat, mor )
    
      return IdentityMorphism( cat, ImageObject( cat, mor ) );
    
    end
  ] : CategoryFilter := HasIsElementaryTopos and IsElementaryTopos );
